<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="编程随想">
<meta property="og:type" content="website">
<meta property="og:title" content="sleepyhead沉思录">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="sleepyhead沉思录">
<meta property="og:description" content="编程随想">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sleepyhead沉思录">
<meta name="twitter:description" content="编程随想">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>sleepyhead沉思录</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sleepyhead沉思录</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">繁荣昌盛，生生不息</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/可重入锁ReentrantLock详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/可重入锁ReentrantLock详解/" class="post-title-link" itemprop="url">可重入锁ReentrantLock详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-25 21:57:00" itemprop="dateCreated datePublished" datetime="2019-02-25T21:57:00+08:00">2019-02-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-18 18:57:06" itemprop="dateModified" datetime="2019-03-18T18:57:06+08:00">2019-03-18</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/25/可重入锁ReentrantLock详解/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/25/可重入锁ReentrantLock详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="可重入锁ReentrantLock"><a href="#可重入锁ReentrantLock" class="headerlink" title="可重入锁ReentrantLock"></a>可重入锁ReentrantLock</h1><h2 id="可重入锁简单示例"><a href="#可重入锁简单示例" class="headerlink" title="可重入锁简单示例"></a>可重入锁简单示例</h2><p>可重入锁可以完全替代synchronized关键字，JDK5.0早期版本中可重入锁性能远远好于synchronized，而从JDK6.0开始，JDK在synchronized上进行了大量的优化，<strong>现在两者的性能差别并不大</strong> 。</p>
<p>重入锁使用<strong>java.util.concurrent.locks.ReentrantLock</strong>类来实现，下面是一段简单的重入锁使用案例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.example.reentrantLock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">//可重入锁的简单应用</span><br><span class="line">public class ReenterLock implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static int i = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int j = 0; j &lt; 10000000; j++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            //可重入锁是可以反复进入的</span><br><span class="line">            //lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                //lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ReenterLock tl = new ReenterLock();</span><br><span class="line">        //启动线程的方法之一</span><br><span class="line">        Thread t1 = new Thread(tl);</span><br><span class="line">        Thread t2 = new Thread(tl);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        //join方法会抛出InterruptedException异常，join()方法会阻塞当前线程直至目标线程执行完毕</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可重入锁是可以反复进入的，但这里的反复仅局限于一个线程，<strong>一个线程连续两次获得同一把锁，是允许的 </strong>，但需要注意，若一个线程多次获得锁，释放锁时也必须释放相同次数，如果释放锁的次数多了，会得到IllegalMonitorStateException异常，若释放锁的次数少了，相当于线程还持有这个锁，此时，其他线程也无法进入临界区。可重入锁还有一些高级功能，比如提供<strong>中断处理</strong>的能力：</p>
<h2 id="可重入锁的中断处理"><a href="#可重入锁的中断处理" class="headerlink" title="可重入锁的中断处理"></a>可重入锁的中断处理</h2><p>中断处理提供一套机制，如果一个线程正在等待锁，能够收到一个通知，被告知不用再等待，可以停止工作了，这种情况对于处理死锁是很有帮助的。<strong>下面的代码产生了一个死锁，但由于锁中断，可以轻易解决这个问题</strong>，可重入锁的中断响应是<strong>解决死锁问题</strong>的一个有效手段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.example.reentrantLock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class IntLock implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public static ReentrantLock lock1 = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static ReentrantLock lock2 = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    int lock;</span><br><span class="line"></span><br><span class="line">    //控制加锁顺序，方便构造死锁</span><br><span class="line">    public IntLock(int lock) &#123;</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (lock == 1) &#123;</span><br><span class="line">                //lockInterruptibly()方法也会抛出异常</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + &quot;:线程抛出异常 lock=&quot; + lock);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (lock1.isHeldByCurrentThread())</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            if (lock2.isHeldByCurrentThread())</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + &quot;:线程退出&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        IntLock r1 = new IntLock(1);</span><br><span class="line">        IntLock r2 = new IntLock(2);</span><br><span class="line">        Thread t1 = new Thread(r1);</span><br><span class="line">        Thread t2 = new Thread(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        //这里中断其中一个线程，而lockInterruptibly是一个可以对中断进行相应的锁申请动作，在等待锁的过程中响应中断</span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是对应的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException</span><br><span class="line">13:线程抛出异常 lock=2</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)</span><br><span class="line">13:线程退出</span><br><span class="line">12:线程退出</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)</span><br><span class="line">	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)</span><br><span class="line">	at com.example.reentrantLock.IntLock.run(IntLock.java:34)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="可重入锁的申请等待限时"><a href="#可重入锁的申请等待限时" class="headerlink" title="可重入锁的申请等待限时"></a>可重入锁的申请等待限时</h2><p>通常无法判断一个线程为什么迟迟拿不到锁，可能是因为饥饿，可能是由于死锁了，给定一个等待时间，<strong>让线程自动放弃</strong>，这个行为是很有意义的，用ReentrantLock.tryLock()方法进行一次限时的等待，下面展示限时等待锁的简单使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package com.example.reentrantLock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">//展示不带参数的ReentrantLock.tryLock()的使用</span><br><span class="line">//避免死锁的另一种方法</span><br><span class="line">public class TryLock implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public static ReentrantLock lock1 = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static ReentrantLock lock2 = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    int lock;</span><br><span class="line"></span><br><span class="line">    public TryLock(int lock) &#123;</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (lock == 1) &#123;</span><br><span class="line">            //tryLock()不带参数直接运行时，当前线程尝试获得锁，锁未被其他线程占用则申请锁成功，返回true，否则返回false，这种模式不会引起线程等待</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (lock1.tryLock()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(500);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (lock2.tryLock()) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getId() + &quot;:My Job done&quot;);</span><br><span class="line">                                return;</span><br><span class="line">                            &#125; finally &#123;</span><br><span class="line">                                lock2.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock1.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (lock2.tryLock()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(500);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        if (lock1.tryLock()) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getId() + &quot;:My Job done!&quot;);</span><br><span class="line">                                return;</span><br><span class="line">                            &#125; finally &#123;</span><br><span class="line">                                lock1.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock2.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        TryLock r1 = new TryLock(1);</span><br><span class="line">        TryLock r2 = new TryLock(2);</span><br><span class="line">        Thread t1 = new Thread(r1);</span><br><span class="line">        Thread t2 = new Thread(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12:My Job done</span><br><span class="line">13:My Job done!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>上述代码采用很容易死锁的加锁顺序，就是先让t1获得lock1，再让t2获得lock2，接着做反向请求，让t1申请lock2，t2申请lock1。在一般情况下，这会导致t1与t2相互等待，从而引起死锁。使用tryLock()后情况大大改善，执行足够长的时间，线程总会得到想要的资源，最后正常执行。</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>多数情况下，锁的申请是非公平的，线程1首先请求锁A，接着线程2也请求了锁A，当锁A可用时，是线程1可以获得锁还是线程2可以获得锁呢。这是不一定的，系统从这个锁的等待队列中随机挑选一个，不能保证其公平性，而公平的锁则不会这样，会按照时间的先后顺序保证先到者先得，后到者后得，若用synchronized关键字进行锁控制，产生的锁就是非公平的，而重入锁允许我们对公平性进行设置。有一个如下的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair)</span><br></pre></td></tr></table></figure>
<p>参数fair为true时，表示锁是公平的，公平锁看起来很优美，但是要实现公平锁必然要求系统维护一个有序队列，因此公平锁实现成本较高，性能也相对较低，所以默认情况下锁是非公平的。如果没有特殊的需求，也不需要实现公平锁。非公平锁和公平锁在线程调度表现上也是非常不一样的。可以看到下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.example.reentrantLock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class FairLock implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    //这里指定锁是公平的</span><br><span class="line">    public static ReentrantLock fairLock = new ReentrantLock(true);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fairLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;获得锁&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                fairLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        FairLock r1 = new FairLock();</span><br><span class="line">        Thread t1 = new Thread(r1, &quot;Thread_t1&quot;);</span><br><span class="line">        Thread t2 = new Thread(r1, &quot;Thread_t2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread_t1获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t1获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t1获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t1获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t1获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t1获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t1获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t1获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t1获得锁</span><br></pre></td></tr></table></figure>
<p>输出中可以看到两个线程基本上是交替获得锁的，几乎不会发生同一个线程连续多次获得锁的可能，不使用公平锁时情况会完全不一样，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br><span class="line">Thread_t2获得锁</span><br></pre></td></tr></table></figure>
<p>可以看到根据系统的调度，一个线程会倾向于再次获取已经持有的锁，这种分配方式是高效的，但是没有公平性可言。</p>
<h2 id="整理ReentrantLock的几个重要方法"><a href="#整理ReentrantLock的几个重要方法" class="headerlink" title="整理ReentrantLock的几个重要方法"></a>整理ReentrantLock的几个重要方法</h2><ul>
<li>lock()，获得锁，若是锁已经被占用，则等待，若是同一个线程多次lock()，是可行的</li>
<li>lockInterruptibly()，获得锁，但是优先响应中断</li>
<li>tryLock()，尝试获得锁，如果成功返回true，失败返回false，该方法不等待，立即返回</li>
<li>tryLock(long time, TimeUnit unit)，在给定时间内尝试获得锁</li>
<li>unlock()，释放锁，以上几个获取锁的方式都是用unlock()释放锁</li>
</ul>
<h2 id="看看重入锁的实现"><a href="#看看重入锁的实现" class="headerlink" title="看看重入锁的实现"></a>看看重入锁的实现</h2><ul>
<li>原子状态，原子状态使用CAS操作来存储当前锁的状态，判断锁是否被别的线程拥有</li>
<li>等待队列，所有没有请求到锁的线程，会进入等待队列进行等待，待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作</li>
<li>阻塞原语park()与unpark()，用来挂起和恢复线程。没有得到锁的线程将被挂起。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/高效读写的队列：ConcurrentLinkedQueue/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/高效读写的队列：ConcurrentLinkedQueue/" class="post-title-link" itemprop="url">高效读写的队列：ConcurrentLinkedQueue</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-25 11:15:05" itemprop="dateCreated datePublished" datetime="2019-02-25T11:15:05+08:00">2019-02-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-27 20:09:13" itemprop="dateModified" datetime="2019-03-27T20:09:13+08:00">2019-03-27</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/25/高效读写的队列：ConcurrentLinkedQueue/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/25/高效读写的队列：ConcurrentLinkedQueue/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="剖析ConcurrentLinkedQueue"><a href="#剖析ConcurrentLinkedQueue" class="headerlink" title="剖析ConcurrentLinkedQueue"></a>剖析ConcurrentLinkedQueue</h2><p>Queue是常用的数据结构之一，在JDK中提供了一个ConcurrentLinkedQueue类用来实现高并发队列。<strong>这个队列利用链表作为其数据结构</strong>，ConcurrentLinkedQueue应该算是高并发环境下<strong>性能最好</strong>的队列。</p>
<p>下面介绍ConcurrentLinkedQueue的实现细节，注意它的实现与无锁操作有关（CAS)。</p>
<p>既然是用链表实现的，链表中自然会定义相关的节点，在ConcurrentLinkedQueue中，定义的节点Node核心如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    volatile E item;</span><br><span class="line">    volatile Node&lt;E&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>item用来存放目标元素，比如列表中存放String时，item就是String类型，字段next表示当前Node的下一个元素，这样每个Node就能环环相扣，串在一起。</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，采用先进先出的规则对节点进行排序，添加一个元素时，添加到队列尾部，获取一个元素时，返回队列头部的元素，它采用CAS算法实现。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/可重入锁的好搭档：Condition条件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/18/可重入锁的好搭档：Condition条件/" class="post-title-link" itemprop="url">可重入锁的好搭档：Condition条件</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-18 10:54:21" itemprop="dateCreated datePublished" datetime="2019-02-18T10:54:21+08:00">2019-02-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-18 18:57:50" itemprop="dateModified" datetime="2019-03-18T18:57:50+08:00">2019-03-18</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/18/可重入锁的好搭档：Condition条件/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/18/可重入锁的好搭档：Condition条件/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="可重入锁相关：Condition条件"><a href="#可重入锁相关：Condition条件" class="headerlink" title="可重入锁相关：Condition条件"></a>可重入锁相关：Condition条件</h1><p>Condition对象与<strong>wait()</strong>及<strong>notify()</strong>方法的作用大致是相同的，但是wait()与notify()方法是与synchronized关键字合作使用的，而Condition是与可重入锁相关联的，利用ReentrantLock实现的Lock接口的Condition newCondition()方法可以生成一个与当前重入锁绑定的Condition实例，利用Condition对象，可以让线程在合适的时候等待，或是在某一个特定时间得到通知，继续执行。以下是Condition接口提供的基本方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void await() throws InterruptedException;</span><br><span class="line">void awaitUninterruptibly();</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">void signal();</span><br><span class="line">void signalAll();</span><br></pre></td></tr></table></figure>
<p>Condition接口提供的await()方法会使当前线程等待，同时释放当前锁，而当其他线程使用signal()或是signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时也能跳出等待。这与Object.wait()方法很相似。而awaitUninterruptibly()方法与await()方法相似，但是并不会在等待过程中被中断。signal()方法唤醒一个在等待中的线程，signalAll()方法唤醒所有在等待过程中的线程，这与Object.notify()方法相似。下面是展示Condition功能的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.example.reentrantLock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ReenterLockCondition implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;线程在等待&quot;);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(&quot;Thread is going on&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ReenterLockCondition tl = new ReenterLockCondition();</span><br><span class="line">        Thread t1 = new Thread(tl);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        //通知线程t1继续执行</span><br><span class="line">        lock.lock();</span><br><span class="line">        condition.signal();</span><br><span class="line">        //线程使用Condition.await()和Condition.signal()时都要求持有相关的重入锁，signal方法调用后一般需要释放相关的锁，谦让给被唤醒的线程</span><br><span class="line">        //signal()唤醒的线程会重新试图获取与其绑定的重入锁，一旦成功获取，就可以继续执行了</span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDK中有关可重入锁与Condition对象的使用"><a href="#JDK中有关可重入锁与Condition对象的使用" class="headerlink" title="JDK中有关可重入锁与Condition对象的使用"></a>JDK中有关可重入锁与Condition对象的使用</h2><p>以ArrayBlockingQueue为例，其put方法实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//ArrayBlockingQueue中的一些定义</span><br><span class="line">private final ReentrantLock lock;</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line">private final Condition notFull;</span><br><span class="line">lock = new ReentrantLock(fair);</span><br><span class="line">//生成两个与lock绑定的Condition</span><br><span class="line">notEmpty = lock.newCondition();</span><br><span class="line">notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">//put方法的实现</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">    throw new NullPointerException();</span><br><span class="line">    final E[] items = this.items;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //可以响应中断</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        //如果当前队列已满，需要等待队列有足够的空间</span><br><span class="line">            while (count == items.length)</span><br><span class="line">               notFull.await();</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            throw ie;</span><br><span class="line">        &#125;</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//insert方法</span><br><span class="line">private void insert(E x) &#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    //通知需要take()的线程，队列已有数据</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//与put方法相对应的take方法实现如下</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //对take()方法进行同步</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //队列为空时，消费者队列需要一个非空的信号</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">            throw ie;</span><br><span class="line">        &#125;</span><br><span class="line">        E x = extract();</span><br><span class="line">        return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E extract() &#123;</span><br><span class="line">    final E[] items = this.items;</span><br><span class="line">    E x = items[takeIndex];</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    takeIndex = inc(takeIndex);</span><br><span class="line">    --count;</span><br><span class="line">    //通知put()线程队列已有空闲空间</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayBlockingQueue是一个用数组实现的线程安全的有界的阻塞队列，阻塞队列是指多线程访问竞争资源时，当竞争资源都被某线程获取时，其他要获取该资源的线程需要阻塞等待。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/ReadWriteLock读写锁/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/14/ReadWriteLock读写锁/" class="post-title-link" itemprop="url">ReadWriteLock读写锁</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-14 20:34:09" itemprop="dateCreated datePublished" datetime="2019-02-14T20:34:09+08:00">2019-02-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-18 18:56:37" itemprop="dateModified" datetime="2019-03-18T18:56:37+08:00">2019-03-18</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/14/ReadWriteLock读写锁/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/14/ReadWriteLock读写锁/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="读写锁：ReadWriteLock"><a href="#读写锁：ReadWriteLock" class="headerlink" title="读写锁：ReadWriteLock"></a>读写锁：ReadWriteLock</h1><p>ReadWriteLock是JDK5中提供的读写分离锁，读写分离锁可以有效的帮助减少锁竞争，来提升系统性能。用锁分离的机制来提升性能是容易理解的，比如线程A1，A2，A3进行写操作，B1，B2，B3进行读操作，如果使用重入锁或者内部锁，则所有读之间，读和写之间，写和写之间都是串行操作（写对数据完整性造成破坏，所以读与写之间，写与写之间必须互斥）。当B1进行读取时，B2，B3都需要等待锁。由于读操作并不对数据完整性造成破坏，这种等待是不合理的，所以，读写锁就有发挥功能的余地。</p>
<p>这种情况下，读写锁允许多个线程同时读，使B1，B2，B3间真正并行，但是考虑到数据完整性，写写操作与读写操作间依然需要相互等待和持有锁。总的来说，读写锁的访问约束如下：</p>
<ul>
<li>读-读不互斥：读读之间不阻塞</li>
<li>读-写互斥：读阻塞写，写也会阻塞读</li>
<li>写-写互斥：写写互斥</li>
</ul>
<p>若在系统中，<strong>读操作次数远远大于写操作次数，则读写锁可以发挥最大功效，提升系统的性能</strong>，下面是读写锁对性能的帮助：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.example.readwritelock;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    private static Lock readLock = readWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    private static Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    public Object handleRead(Lock lock) throws InterruptedException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //模拟读操作，读操作耗时越多，读写锁优势越明显</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            return value;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handleWrite(Lock lock, int index) throws InterruptedException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            //模拟写操作</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            value = index;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final ReadWriteLockDemo demo = new ReadWriteLockDemo();</span><br><span class="line">        Runnable readRunnale = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //demo.handleRead(readLock);</span><br><span class="line">                    demo.handleRead(lock);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeRunnale = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //若使用普通的重入锁代替读写锁，那么所有的读和写线程之间必须相互等待，耗时将非常长</span><br><span class="line">                try &#123;</span><br><span class="line">                    //demo.handleWrite(writeLock, new Random().nextInt());</span><br><span class="line">                    demo.handleWrite(lock, new Random().nextInt());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 18; i++) &#123;</span><br><span class="line">            new Thread(readRunnale).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 18; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(writeRunnale).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易发现，使用普通的重入锁代替读写锁，所有的读和写线程间都必须相互等待，整个程序执行时间会长达20秒，而采用读写锁时，大约2秒多就能结束，读写分离使读线程完全并行，而写会阻塞读，这里是读操作次数远远大于写的情况，读写锁发挥很大功效。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/Mysql中的锁/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/21/Mysql中的锁/" class="post-title-link" itemprop="url">Mysql中的锁</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-21 14:57:24" itemprop="dateCreated datePublished" datetime="2019-01-21T14:57:24+08:00">2019-01-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-21 16:44:28" itemprop="dateModified" datetime="2019-03-21T16:44:28+08:00">2019-03-21</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/21/Mysql中的锁/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/21/Mysql中的锁/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mysql中的锁"><a href="#Mysql中的锁" class="headerlink" title="Mysql中的锁"></a>Mysql中的锁</h1><p>我们要开发多用户，数据库驱动的应用，有一个难点是要最大程度利用数据库的并发访问，而且还要确保每个用户能以一致的方式去读取和修改数据。所以就有了锁的机制，这也是数据库系统区分于文件系统的一个关键特性。InnoDB引擎与Mysql的其他存储引擎相比，在此方面更具优势，只有正确了解这些锁的内部机制才能够充分发挥InnoDB引擎在锁方面的优势。</p>
<h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>锁是数据库系统区别于文件系统的一个关键特性，锁机制管理对共享资源的并发访问。<strong>InnoDb存储引擎会在行级别上对表数据上锁</strong>，这是OK的。而且除了表数据以外，InnoDB存储引擎也在数据库内部其他地方使用锁，从而为不同的多种资源提供并发访问。比如操作缓冲池中的LRU列表，删除，添加，移动LRU列表中的元素，为保证一致性，必须要有锁的介入。<strong>数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性与一致性。</strong></p>
<p>在不同数据库之中，锁的实现是多种多样的，SQL语法层面，由于SQL标准的存在，易于熟悉多个关系数据库系统。但是对于锁，用户可能只对特定系统的锁定模型有一定经验。但这不意味着熟悉其他数据库的锁定模型。举例来说，MySQL的InnoDB存储引擎和MyISAM存储引擎对锁的实现完全不同。</p>
<p><strong>MyISAM的锁是表锁设计</strong>，并发情况下的读是没有问题的，但是并发插入的性能就要差一些。而对于SQL Server数据库，在SQL Server2005版本前都是页锁，相对表锁的MyISAM引擎，并发性能是更高的，到2005版本，SQL server开始支持<strong>乐观并发</strong>与<strong>悲观并发</strong>，在乐观并发下开始支持行级锁，但它的实现方式和InnoDB存储引擎的实现方式完全不同，在SQL Server下，锁是一种稀有的资源，锁越多，开销越大，这种情况下会有<strong>锁升级</strong>，行锁会升级到表锁，这时并发性能又回到了以前。</p>
<p>InnoDB存储引擎锁的实现与Oracle很类似，提供一致性的非锁定读，行级锁支持。行级锁没有相关额外的开销，而且可以同时得到并发性和一致性。</p>
<h2 id="Lock与Latch"><a href="#Lock与Latch" class="headerlink" title="Lock与Latch"></a>Lock与Latch</h2><p>数据库中，Lock与Latch都称为锁，但两者截然不同，<strong>这里主要关注lock</strong>。</p>
<p>latch为轻量级的锁，其要求锁定的时间很短，若持续时间长，则应用的性能会非常差，在InnoDB存储引擎中，latch又可以分为mutex和rwlock。目的是保证并发线程操作临界资源的准确性，而且Latch通常没有死锁检测的机制。</p>
<p>而lock的对象为事务，用来<strong>锁定数据库中的对象</strong>，比如<strong>表，行，页</strong>。而且一般lock的对象只在事务commit或rollback后释放。（不同事务隔离级别释放的时间可能不同）。此外，<strong>lock是有死锁机制的</strong>。</p>
<h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><p>InnoDB存储引擎实现如下两种标准的行级锁：</p>
<ul>
<li><strong>共享锁，允许事务读一行数据</strong>(S Lock)</li>
<li><strong>排他锁，允许事务删除或者更新一行数据</strong>(X Lock)</li>
</ul>
<p>如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并未改变行r的数据，这种情况叫锁兼容。若事务T3想获得行r的排他锁，则<strong>必须等待事务T1，T2释放行r上的共享锁</strong>。这种情况叫锁不兼容。X锁和任何的锁都不兼容，而S锁仅与S锁兼容。注意S和X都是行锁，兼容是指对同一记录锁的兼容性情况。</p>
<p>此外，InnoDB存储引擎支持多粒度锁定，<strong>这种锁定支持事务在行级上的锁和表级上的锁同时存在</strong>，为支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的加锁方式，称为<strong>意向锁</strong>，意向锁是将锁定的对象分为多个层次，这意味着事务希望在更细粒度上进行加锁。</p>
<p>若将上锁的对象看作一棵树，对最下层的对象上锁，也就是对最细粒度的对象上锁，则需要对数据库A，表，页上意向锁IX，最后对记录r上X锁。若任何一部分导致等待，则该操作需要等待粗粒度锁的完成。</p>
<p>InnoDB对意向锁的支持比较简练，其意向锁即为表级别的锁，支持两种意向锁：</p>
<ul>
<li>意向共享锁（IS LOCK），事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁（IX LOCK），事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>因为InnoDB存储引擎支持的是行级别的锁，所以意向锁不会阻塞除全表扫描以外的任何请求。所以表级意向锁和行级锁的兼容性可以查表得到。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/12/ArrayList与LinkedList/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/12/ArrayList与LinkedList/" class="post-title-link" itemprop="url">ArrayList与LinkedList详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-12 19:47:30" itemprop="dateCreated datePublished" datetime="2019-01-12T19:47:30+08:00">2019-01-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-05 15:05:16" itemprop="dateModified" datetime="2019-04-05T15:05:16+08:00">2019-04-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java并发编程/" itemprop="url" rel="index"><span itemprop="name">Java并发编程</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/12/ArrayList与LinkedList/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/12/ArrayList与LinkedList/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ArrayList详解"><a href="#ArrayList详解" class="headerlink" title="ArrayList详解"></a>ArrayList详解</h1><h2 id="ArrayList介绍"><a href="#ArrayList介绍" class="headerlink" title="ArrayList介绍"></a>ArrayList介绍</h2><p>ArrayList 是一个<strong>数组队列</strong>，相当于 <strong>动态数组</strong>。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。</p>
<p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。<br>ArrayList 实现了RandmoAccess接口，即提供了<strong>随机访问功能</strong>。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。</p>
<p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>
<p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p>
<p>和Vector不同，<strong>ArrayList中的操作不是线程安全的</strong>！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。</p>
<p> 下面看看ArrayList的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 默认构造函数</span><br><span class="line">ArrayList()</span><br><span class="line"></span><br><span class="line">// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。</span><br><span class="line">ArrayList(int capacity)</span><br><span class="line"></span><br><span class="line">// 创建一个包含collection的ArrayList</span><br><span class="line">ArrayList(Collection&lt;? extends E&gt; collection)</span><br></pre></td></tr></table></figure>
<p>ArrayList的API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Collection中定义的API</span><br><span class="line">boolean             add(E object)</span><br><span class="line">boolean             addAll(Collection&lt;? extends E&gt; collection)</span><br><span class="line">void                clear()</span><br><span class="line">boolean             contains(Object object)</span><br><span class="line">boolean             containsAll(Collection&lt;?&gt; collection)</span><br><span class="line">boolean             equals(Object object)</span><br><span class="line">int                 hashCode()</span><br><span class="line">boolean             isEmpty()</span><br><span class="line">Iterator&lt;E&gt;         iterator()</span><br><span class="line">boolean             remove(Object object)</span><br><span class="line">boolean             removeAll(Collection&lt;?&gt; collection)</span><br><span class="line">boolean             retainAll(Collection&lt;?&gt; collection)</span><br><span class="line">int                 size()</span><br><span class="line">&lt;T&gt; T[]             toArray(T[] array)</span><br><span class="line">Object[]            toArray()</span><br><span class="line">// AbstractCollection中定义的API</span><br><span class="line">void                add(int location, E object)</span><br><span class="line">boolean             addAll(int location, Collection&lt;? extends E&gt; collection)</span><br><span class="line">E                   get(int location)</span><br><span class="line">int                 indexOf(Object object)</span><br><span class="line">int                 lastIndexOf(Object object)</span><br><span class="line">ListIterator&lt;E&gt;     listIterator(int location)</span><br><span class="line">ListIterator&lt;E&gt;     listIterator()</span><br><span class="line">E                   remove(int location)</span><br><span class="line">E                   set(int location, E object)</span><br><span class="line">List&lt;E&gt;             subList(int start, int end)</span><br><span class="line">// ArrayList新增的API</span><br><span class="line">Object               clone()</span><br><span class="line">void                 ensureCapacity(int minimumCapacity)</span><br><span class="line">void                 trimToSize()</span><br><span class="line">void                 removeRange(int fromIndex, int toIndex)</span><br></pre></td></tr></table></figure>
<h2 id="ArrayList内部数据结构"><a href="#ArrayList内部数据结构" class="headerlink" title="ArrayList内部数据结构"></a>ArrayList内部数据结构</h2><p>ArrayList包含了两个重要的对象：elementData 和 size。</p>
<p>(1) elementData 是”Object[]类型的数组”，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是10。elementData数组的大小会根据ArrayList容量的增长而动态的增长，具体的增长方式，请参考源码分析中的ensureCapacity()函数。</p>
<p>(2) size 则是动态数组的实际大小。</p>
<h2 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h2><p>ArrayList通过数组实现，源码比较容易理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line">  1 package java.util;</span><br><span class="line">  2 </span><br><span class="line">  3 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">  4         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">  5 &#123;</span><br><span class="line">  6     // 序列版本号</span><br><span class="line">  7     private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line">  8 </span><br><span class="line">  9     // 保存ArrayList中数据的数组</span><br><span class="line"> 10     private transient Object[] elementData;</span><br><span class="line"> 11 </span><br><span class="line"> 12     // ArrayList中实际数据的数量</span><br><span class="line"> 13     private int size;</span><br><span class="line"> 14 </span><br><span class="line"> 15     // ArrayList带容量大小的构造函数。</span><br><span class="line"> 16     public ArrayList(int initialCapacity) &#123;</span><br><span class="line"> 17         super();</span><br><span class="line"> 18         if (initialCapacity &lt; 0)</span><br><span class="line"> 19             throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line"> 20                                                initialCapacity);</span><br><span class="line"> 21         // 新建一个数组</span><br><span class="line"> 22         this.elementData = new Object[initialCapacity];</span><br><span class="line"> 23     &#125;</span><br><span class="line"> 24 </span><br><span class="line"> 25     // ArrayList构造函数。默认容量是10。</span><br><span class="line"> 26     public ArrayList() &#123;</span><br><span class="line"> 27         this(10);</span><br><span class="line"> 28     &#125;</span><br><span class="line"> 29 </span><br><span class="line"> 30     // 创建一个包含collection的ArrayList</span><br><span class="line"> 31     public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line"> 32         elementData = c.toArray();</span><br><span class="line"> 33         size = elementData.length;</span><br><span class="line"> 34         // c.toArray might (incorrectly) not return Object[] (see        6260652)</span><br><span class="line"> 35         if (elementData.getClass() != Object[].class)</span><br><span class="line"> 36             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line"> 37     &#125;</span><br><span class="line"> 38 </span><br><span class="line"> 39 </span><br><span class="line"> 40     // 将当前容量值设为 =实际元素个数</span><br><span class="line"> 41     public void trimToSize() &#123;</span><br><span class="line"> 42         modCount++;</span><br><span class="line"> 43         int oldCapacity = elementData.length;</span><br><span class="line"> 44         if (size &lt; oldCapacity) &#123;</span><br><span class="line"> 45             elementData = Arrays.copyOf(elementData, size);</span><br><span class="line"> 46         &#125;</span><br><span class="line"> 47     &#125;</span><br><span class="line"> 48 </span><br><span class="line"> 49 </span><br><span class="line"> 50     // 确定ArrarList的容量。</span><br><span class="line"> 51     // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2  + 1”</span><br><span class="line"> 52     public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line"> 53         // 将“修改统计数”+1</span><br><span class="line"> 54         modCount++;</span><br><span class="line"> 55         int oldCapacity = elementData.length;</span><br><span class="line"> 56         // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”</span><br><span class="line"> 57         if (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line"> 58             Object oldData[] = elementData;</span><br><span class="line"> 59             int newCapacity = (oldCapacity * 3)/2 + 1;</span><br><span class="line"> 60             if (newCapacity &lt; minCapacity)</span><br><span class="line"> 61                 newCapacity = minCapacity;</span><br><span class="line"> 62             elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> 63         &#125;</span><br><span class="line"> 64     &#125;</span><br><span class="line"> 65 </span><br><span class="line"> 66     // 添加元素e</span><br><span class="line"> 67     public boolean add(E e) &#123;</span><br><span class="line"> 68         // 确定ArrayList的容量大小</span><br><span class="line"> 69         ensureCapacity(size + 1);  // Increments modCount!!</span><br><span class="line"> 70         // 添加e到ArrayList中</span><br><span class="line"> 71         elementData[size++] = e;</span><br><span class="line"> 72         return true;</span><br><span class="line"> 73     &#125;</span><br><span class="line"> 74 </span><br><span class="line"> 75     // 返回ArrayList的实际大小</span><br><span class="line"> 76     public int size() &#123;</span><br><span class="line"> 77         return size;</span><br><span class="line"> 78     &#125;</span><br><span class="line"> 79 </span><br><span class="line"> 80     // 返回ArrayList是否包含Object(o)</span><br><span class="line"> 81     public boolean contains(Object o) &#123;</span><br><span class="line"> 82         return indexOf(o) &gt;= 0;</span><br><span class="line"> 83     &#125;</span><br><span class="line"> 84 </span><br><span class="line"> 85     // 返回ArrayList是否为空</span><br><span class="line"> 86     public boolean isEmpty() &#123;</span><br><span class="line"> 87         return size == 0;</span><br><span class="line"> 88     &#125;</span><br><span class="line"> 89 </span><br><span class="line"> 90     // 正向查找，返回元素的索引值</span><br><span class="line"> 91     public int indexOf(Object o) &#123;</span><br><span class="line"> 92         if (o == null) &#123;</span><br><span class="line"> 93             for (int i = 0; i &lt; size; i++)</span><br><span class="line"> 94             if (elementData[i]==null)</span><br><span class="line"> 95                 return i;</span><br><span class="line"> 96             &#125; else &#123;</span><br><span class="line"> 97                 for (int i = 0; i &lt; size; i++)</span><br><span class="line"> 98                 if (o.equals(elementData[i]))</span><br><span class="line"> 99                     return i;</span><br><span class="line">100             &#125;</span><br><span class="line">101             return -1;</span><br><span class="line">102         &#125;</span><br><span class="line">103 </span><br><span class="line">104         // 反向查找，返回元素的索引值</span><br><span class="line">105         public int lastIndexOf(Object o) &#123;</span><br><span class="line">106         if (o == null) &#123;</span><br><span class="line">107             for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">108             if (elementData[i]==null)</span><br><span class="line">109                 return i;</span><br><span class="line">110         &#125; else &#123;</span><br><span class="line">111             for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">112             if (o.equals(elementData[i]))</span><br><span class="line">113                 return i;</span><br><span class="line">114         &#125;</span><br><span class="line">115         return -1;</span><br><span class="line">116     &#125;</span><br><span class="line">117 </span><br><span class="line">118     // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值</span><br><span class="line">119     public int lastIndexOf(Object o) &#123;</span><br><span class="line">120         if (o == null) &#123;</span><br><span class="line">121             for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">122             if (elementData[i]==null)</span><br><span class="line">123                 return i;</span><br><span class="line">124         &#125; else &#123;</span><br><span class="line">125             for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">126             if (o.equals(elementData[i]))</span><br><span class="line">127                 return i;</span><br><span class="line">128         &#125;</span><br><span class="line">129         return -1;</span><br><span class="line">130     &#125;</span><br><span class="line">131  </span><br><span class="line">132 </span><br><span class="line">133     // 返回ArrayList的Object数组</span><br><span class="line">134     public Object[] toArray() &#123;</span><br><span class="line">135         return Arrays.copyOf(elementData, size);</span><br><span class="line">136     &#125;</span><br><span class="line">137 </span><br><span class="line">138     // 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型</span><br><span class="line">139     public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">140         // 若数组a的大小 &lt; ArrayList的元素个数；</span><br><span class="line">141         // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中</span><br><span class="line">142         if (a.length &lt; size)</span><br><span class="line">143             return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">144 </span><br><span class="line">145         // 若数组a的大小 &gt;= ArrayList的元素个数；</span><br><span class="line">146         // 则将ArrayList的全部元素都拷贝到数组a中。</span><br><span class="line">147         System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">148         if (a.length &gt; size)</span><br><span class="line">149             a[size] = null;</span><br><span class="line">150         return a;</span><br><span class="line">151     &#125;</span><br><span class="line">152 </span><br><span class="line">153     // 获取index位置的元素值</span><br><span class="line">154     public E get(int index) &#123;</span><br><span class="line">155         RangeCheck(index);</span><br><span class="line">156 </span><br><span class="line">157         return (E) elementData[index];</span><br><span class="line">158     &#125;</span><br><span class="line">159 </span><br><span class="line">160     // 设置index位置的值为element</span><br><span class="line">161     public E set(int index, E element) &#123;</span><br><span class="line">162         RangeCheck(index);</span><br><span class="line">163 </span><br><span class="line">164         E oldValue = (E) elementData[index];</span><br><span class="line">165         elementData[index] = element;</span><br><span class="line">166         return oldValue;</span><br><span class="line">167     &#125;</span><br><span class="line">168 </span><br><span class="line">169     // 将e添加到ArrayList中</span><br><span class="line">170     public boolean add(E e) &#123;</span><br><span class="line">171         ensureCapacity(size + 1);  // Increments modCount!!</span><br><span class="line">172         elementData[size++] = e;</span><br><span class="line">173         return true;</span><br><span class="line">174     &#125;</span><br><span class="line">175 </span><br><span class="line">176     // 将e添加到ArrayList的指定位置</span><br><span class="line">177     public void add(int index, E element) &#123;</span><br><span class="line">178         if (index &gt; size || index &lt; 0)</span><br><span class="line">179             throw new IndexOutOfBoundsException(</span><br><span class="line">180             &quot;Index: &quot;+index+&quot;, Size: &quot;+size);</span><br><span class="line">181 </span><br><span class="line">182         ensureCapacity(size+1);  // Increments modCount!!</span><br><span class="line">183         System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">184              size - index);</span><br><span class="line">185         elementData[index] = element;</span><br><span class="line">186         size++;</span><br><span class="line">187     &#125;</span><br><span class="line">188 </span><br><span class="line">189     // 删除ArrayList指定位置的元素</span><br><span class="line">190     public E remove(int index) &#123;</span><br><span class="line">191         RangeCheck(index);</span><br><span class="line">192 </span><br><span class="line">193         modCount++;</span><br><span class="line">194         E oldValue = (E) elementData[index];</span><br><span class="line">195 </span><br><span class="line">196         int numMoved = size - index - 1;</span><br><span class="line">197         if (numMoved &gt; 0)</span><br><span class="line">198             System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">199                  numMoved);</span><br><span class="line">200         elementData[--size] = null; // Let gc do its work</span><br><span class="line">201 </span><br><span class="line">202         return oldValue;</span><br><span class="line">203     &#125;</span><br><span class="line">204 </span><br><span class="line">205     // 删除ArrayList的指定元素</span><br><span class="line">206     public boolean remove(Object o) &#123;</span><br><span class="line">207         if (o == null) &#123;</span><br><span class="line">208                 for (int index = 0; index &lt; size; index++)</span><br><span class="line">209             if (elementData[index] == null) &#123;</span><br><span class="line">210                 fastRemove(index);</span><br><span class="line">211                 return true;</span><br><span class="line">212             &#125;</span><br><span class="line">213         &#125; else &#123;</span><br><span class="line">214             for (int index = 0; index &lt; size; index++)</span><br><span class="line">215             if (o.equals(elementData[index])) &#123;</span><br><span class="line">216                 fastRemove(index);</span><br><span class="line">217                 return true;</span><br><span class="line">218             &#125;</span><br><span class="line">219         &#125;</span><br><span class="line">220         return false;</span><br><span class="line">221     &#125;</span><br><span class="line">222 </span><br><span class="line">223 </span><br><span class="line">224     // 快速删除第index个元素</span><br><span class="line">225     private void fastRemove(int index) &#123;</span><br><span class="line">226         modCount++;</span><br><span class="line">227         int numMoved = size - index - 1;</span><br><span class="line">228         // 从&quot;index+1&quot;开始，用后面的元素替换前面的元素。</span><br><span class="line">229         if (numMoved &gt; 0)</span><br><span class="line">230             System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">231                              numMoved);</span><br><span class="line">232         // 将最后一个元素设为null</span><br><span class="line">233         elementData[--size] = null; // Let gc do its work</span><br><span class="line">234     &#125;</span><br><span class="line">235 </span><br><span class="line">236     // 删除元素</span><br><span class="line">237     public boolean remove(Object o) &#123;</span><br><span class="line">238         if (o == null) &#123;</span><br><span class="line">239             for (int index = 0; index &lt; size; index++)</span><br><span class="line">240             if (elementData[index] == null) &#123;</span><br><span class="line">241                 fastRemove(index);</span><br><span class="line">242             return true;</span><br><span class="line">243             &#125;</span><br><span class="line">244         &#125; else &#123;</span><br><span class="line">245             // 便利ArrayList，找到“元素o”，则删除，并返回true。</span><br><span class="line">246             for (int index = 0; index &lt; size; index++)</span><br><span class="line">247             if (o.equals(elementData[index])) &#123;</span><br><span class="line">248                 fastRemove(index);</span><br><span class="line">249             return true;</span><br><span class="line">250             &#125;</span><br><span class="line">251         &#125;</span><br><span class="line">252         return false;</span><br><span class="line">253     &#125;</span><br><span class="line">254 </span><br><span class="line">255     // 清空ArrayList，将全部的元素设为null</span><br><span class="line">256     public void clear() &#123;</span><br><span class="line">257         modCount++;</span><br><span class="line">258 </span><br><span class="line">259         for (int i = 0; i &lt; size; i++)</span><br><span class="line">260             elementData[i] = null;</span><br><span class="line">261 </span><br><span class="line">262         size = 0;</span><br><span class="line">263     &#125;</span><br><span class="line">264 </span><br><span class="line">265     // 将集合c追加到ArrayList中</span><br><span class="line">266     public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">267         Object[] a = c.toArray();</span><br><span class="line">268         int numNew = a.length;</span><br><span class="line">269         ensureCapacity(size + numNew);  // Increments modCount</span><br><span class="line">270         System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">271         size += numNew;</span><br><span class="line">272         return numNew != 0;</span><br><span class="line">273     &#125;</span><br><span class="line">274 </span><br><span class="line">275     // 从index位置开始，将集合c添加到ArrayList</span><br><span class="line">276     public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">277         if (index &gt; size || index &lt; 0)</span><br><span class="line">278             throw new IndexOutOfBoundsException(</span><br><span class="line">279             &quot;Index: &quot; + index + &quot;, Size: &quot; + size);</span><br><span class="line">280 </span><br><span class="line">281         Object[] a = c.toArray();</span><br><span class="line">282         int numNew = a.length;</span><br><span class="line">283         ensureCapacity(size + numNew);  // Increments modCount</span><br><span class="line">284 </span><br><span class="line">285         int numMoved = size - index;</span><br><span class="line">286         if (numMoved &gt; 0)</span><br><span class="line">287             System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">288                  numMoved);</span><br><span class="line">289 </span><br><span class="line">290         System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">291         size += numNew;</span><br><span class="line">292         return numNew != 0;</span><br><span class="line">293     &#125;</span><br><span class="line">294 </span><br><span class="line">295     // 删除fromIndex到toIndex之间的全部元素。</span><br><span class="line">296     protected void removeRange(int fromIndex, int toIndex) &#123;</span><br><span class="line">297     modCount++;</span><br><span class="line">298     int numMoved = size - toIndex;</span><br><span class="line">299         System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">300                          numMoved);</span><br><span class="line">301 </span><br><span class="line">302     // Let gc do its work</span><br><span class="line">303     int newSize = size - (toIndex-fromIndex);</span><br><span class="line">304     while (size != newSize)</span><br><span class="line">305         elementData[--size] = null;</span><br><span class="line">306     &#125;</span><br><span class="line">307 </span><br><span class="line">308     private void RangeCheck(int index) &#123;</span><br><span class="line">309     if (index &gt;= size)</span><br><span class="line">310         throw new IndexOutOfBoundsException(</span><br><span class="line">311         &quot;Index: &quot;+index+&quot;, Size: &quot;+size);</span><br><span class="line">312     &#125;</span><br><span class="line">313 </span><br><span class="line">314 </span><br><span class="line">315     // 克隆函数</span><br><span class="line">316     public Object clone() &#123;</span><br><span class="line">317         try &#123;</span><br><span class="line">318             ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();</span><br><span class="line">319             // 将当前ArrayList的全部元素拷贝到v中</span><br><span class="line">320             v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">321             v.modCount = 0;</span><br><span class="line">322             return v;</span><br><span class="line">323         &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">324             // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">325             throw new InternalError();</span><br><span class="line">326         &#125;</span><br><span class="line">327     &#125;</span><br><span class="line">328 </span><br><span class="line">329 </span><br><span class="line">330     // java.io.Serializable的写入函数</span><br><span class="line">331     // 将ArrayList的“容量，所有的元素值”都写入到输出流中</span><br><span class="line">332     private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">333         throws java.io.IOException&#123;</span><br><span class="line">334     // Write out element count, and any hidden stuff</span><br><span class="line">335     int expectedModCount = modCount;</span><br><span class="line">336     s.defaultWriteObject();</span><br><span class="line">337 </span><br><span class="line">338         // 写入“数组的容量”</span><br><span class="line">339         s.writeInt(elementData.length);</span><br><span class="line">340 </span><br><span class="line">341     // 写入“数组的每一个元素”</span><br><span class="line">342     for (int i=0; i&lt;size; i++)</span><br><span class="line">343             s.writeObject(elementData[i]);</span><br><span class="line">344 </span><br><span class="line">345     if (modCount != expectedModCount) &#123;</span><br><span class="line">346             throw new ConcurrentModificationException();</span><br><span class="line">347         &#125;</span><br><span class="line">348 </span><br><span class="line">349     &#125;</span><br><span class="line">350 </span><br><span class="line">351 </span><br><span class="line">352     // java.io.Serializable的读取函数：根据写入方式读出</span><br><span class="line">353     // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出</span><br><span class="line">354     private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">355         throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">356         // Read in size, and any hidden stuff</span><br><span class="line">357         s.defaultReadObject();</span><br><span class="line">358 </span><br><span class="line">359         // 从输入流中读取ArrayList的“容量”</span><br><span class="line">360         int arrayLength = s.readInt();</span><br><span class="line">361         Object[] a = elementData = new Object[arrayLength];</span><br><span class="line">362 </span><br><span class="line">363         // 从输入流中将“所有的元素值”读出</span><br><span class="line">364         for (int i=0; i&lt;size; i++)</span><br><span class="line">365             a[i] = s.readObject();</span><br><span class="line">366     &#125;</span><br><span class="line">367 &#125;</span><br></pre></td></tr></table></figure>
<p>总结源码：</p>
<ul>
<li>ArrayList实际上<strong>通过一个数组去保存数据</strong>，当我们构造ArrayList时；若使用默认构造函数，ArrayList<strong>默认大小为10 </strong>。</li>
<li><p>当ArrayList容量不足以去容纳全部元素时，ArrayList会重新设置容量：<strong>新的容量 = （原始容量*3/2 + 1 </strong>。</p>
</li>
<li><p>ArrayList的克隆函数，即是将全部元素克隆到一个数组中。</p>
</li>
</ul>
<h2 id="ArrayList的遍历方式"><a href="#ArrayList的遍历方式" class="headerlink" title="ArrayList的遍历方式"></a>ArrayList的遍历方式</h2><ul>
<li>迭代器遍历</li>
<li>随机访问，通过索引值遍历</li>
<li>for循环遍历</li>
</ul>
<p><strong>遍历ArrayList时，使用随机访问（通过索引序号访问）效率最高，而使用迭代器效率最低。</strong></p>
<h1 id="LinkedList详解"><a href="#LinkedList详解" class="headerlink" title="LinkedList详解"></a>LinkedList详解</h1><h2 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h2><p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。<br>LinkedList 实现 List 接口，能对它进行队列操作。<br>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。<br>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。<br>LinkedList 是非同步的。</p>
<h2 id="Linkedlist的API"><a href="#Linkedlist的API" class="headerlink" title="Linkedlist的API"></a>Linkedlist的API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">LinkedList的API</span><br><span class="line">boolean       add(E object)</span><br><span class="line">void          add(int location, E object)</span><br><span class="line">boolean       addAll(Collection&lt;? extends E&gt; collection)</span><br><span class="line">boolean       addAll(int location, Collection&lt;? extends E&gt; collection)</span><br><span class="line">void          addFirst(E object)</span><br><span class="line">void          addLast(E object)</span><br><span class="line">void          clear()</span><br><span class="line">Object        clone()</span><br><span class="line">boolean       contains(Object object)</span><br><span class="line">Iterator&lt;E&gt;   descendingIterator()</span><br><span class="line">E             element()</span><br><span class="line">E             get(int location)</span><br><span class="line">E             getFirst()</span><br><span class="line">E             getLast()</span><br><span class="line">int           indexOf(Object object)</span><br><span class="line">int           lastIndexOf(Object object)</span><br><span class="line">ListIterator&lt;E&gt;     listIterator(int location)</span><br><span class="line">boolean       offer(E o)</span><br><span class="line">boolean       offerFirst(E e)</span><br><span class="line">boolean       offerLast(E e)</span><br><span class="line">E             peek()</span><br><span class="line">E             peekFirst()</span><br><span class="line">E             peekLast()</span><br><span class="line">E             poll()</span><br><span class="line">E             pollFirst()</span><br><span class="line">E             pollLast()</span><br><span class="line">E             pop()</span><br><span class="line">void          push(E e)</span><br><span class="line">E             remove()</span><br><span class="line">E             remove(int location)</span><br><span class="line">boolean       remove(Object object)</span><br><span class="line">E             removeFirst()</span><br><span class="line">boolean       removeFirstOccurrence(Object o)</span><br><span class="line">E             removeLast()</span><br><span class="line">boolean       removeLastOccurrence(Object o)</span><br><span class="line">E             set(int location, E object)</span><br><span class="line">int           size()</span><br><span class="line">&lt;T&gt; T[]       toArray(T[] contents)</span><br><span class="line">Object[]     toArray()</span><br></pre></td></tr></table></figure>
<h2 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h2><p>为了更了解LinkedList的原理，<strong>下面对LinkedList源码代码作出分析</strong>。</p>
<p>在阅读源码之前，我们先对LinkedList的整体实现进行大致说明：<br>   LinkedList实际上是通过双向链表去实现的。既然是双向链表，那么它的<strong>顺序访问会非常高效，而随机访问效率比较低</strong>。<br>​    既然LinkedList是通过双向链表的，但是它也实现了List接口{也就是说，它实现了get(int location)、remove(int location)等 “根据索引值来获取、删除节点的函数”}。LinkedList是如何实现List的这些接口的，如何将“双向链表和索引值联系起来的”？<br>​    实际原理非常简单，它就是通过一个<strong>计数索引值</strong>来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置。<br>   这就是“双线链表和索引值联系起来”的方法。</p>
<p>好了，接下来开始阅读源码(只要理解双向链表，那么LinkedList的源码很容易理解的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br></pre></td><td class="code"><pre><span class="line">1 package java.util;</span><br><span class="line">  2 </span><br><span class="line">  3 public class LinkedList&lt;E&gt;</span><br><span class="line">  4     extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">  5     implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">  6 &#123;</span><br><span class="line">  7     // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。</span><br><span class="line">  8     private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null);</span><br><span class="line">  9 </span><br><span class="line"> 10     // LinkedList中元素个数</span><br><span class="line"> 11     private transient int size = 0;</span><br><span class="line"> 12 </span><br><span class="line"> 13     // 默认构造函数：创建一个空的链表</span><br><span class="line"> 14     public LinkedList() &#123;</span><br><span class="line"> 15         header.next = header.previous = header;</span><br><span class="line"> 16     &#125;</span><br><span class="line"> 17 </span><br><span class="line"> 18     // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList</span><br><span class="line"> 19     public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line"> 20         this();</span><br><span class="line"> 21         addAll(c);</span><br><span class="line"> 22     &#125;</span><br><span class="line"> 23 </span><br><span class="line"> 24     // 获取LinkedList的第一个元素</span><br><span class="line"> 25     public E getFirst() &#123;</span><br><span class="line"> 26         if (size==0)</span><br><span class="line"> 27             throw new NoSuchElementException();</span><br><span class="line"> 28 </span><br><span class="line"> 29         // 链表的表头header中不包含数据。</span><br><span class="line"> 30         // 这里返回header所指下一个节点所包含的数据。</span><br><span class="line"> 31         return header.next.element;</span><br><span class="line"> 32     &#125;</span><br><span class="line"> 33 </span><br><span class="line"> 34     // 获取LinkedList的最后一个元素</span><br><span class="line"> 35     public E getLast()  &#123;</span><br><span class="line"> 36         if (size==0)</span><br><span class="line"> 37             throw new NoSuchElementException();</span><br><span class="line"> 38 </span><br><span class="line"> 39         // 由于LinkedList是双向链表；而表头header不包含数据。</span><br><span class="line"> 40         // 因而，这里返回表头header的前一个节点所包含的数据。</span><br><span class="line"> 41         return header.previous.element;</span><br><span class="line"> 42     &#125;</span><br><span class="line"> 43 </span><br><span class="line"> 44     // 删除LinkedList的第一个元素</span><br><span class="line"> 45     public E removeFirst() &#123;</span><br><span class="line"> 46         return remove(header.next);</span><br><span class="line"> 47     &#125;</span><br><span class="line"> 48 </span><br><span class="line"> 49     // 删除LinkedList的最后一个元素</span><br><span class="line"> 50     public E removeLast() &#123;</span><br><span class="line"> 51         return remove(header.previous);</span><br><span class="line"> 52     &#125;</span><br><span class="line"> 53 </span><br><span class="line"> 54     // 将元素添加到LinkedList的起始位置</span><br><span class="line"> 55     public void addFirst(E e) &#123;</span><br><span class="line"> 56         addBefore(e, header.next);</span><br><span class="line"> 57     &#125;</span><br><span class="line"> 58 </span><br><span class="line"> 59     // 将元素添加到LinkedList的结束位置</span><br><span class="line"> 60     public void addLast(E e) &#123;</span><br><span class="line"> 61         addBefore(e, header);</span><br><span class="line"> 62     &#125;</span><br><span class="line"> 63 </span><br><span class="line"> 64     // 判断LinkedList是否包含元素(o)</span><br><span class="line"> 65     public boolean contains(Object o) &#123;</span><br><span class="line"> 66         return indexOf(o) != -1;</span><br><span class="line"> 67     &#125;</span><br><span class="line"> 68 </span><br><span class="line"> 69     // 返回LinkedList的大小</span><br><span class="line"> 70     public int size() &#123;</span><br><span class="line"> 71         return size;</span><br><span class="line"> 72     &#125;</span><br><span class="line"> 73 </span><br><span class="line"> 74     // 将元素(E)添加到LinkedList中</span><br><span class="line"> 75     public boolean add(E e) &#123;</span><br><span class="line"> 76         // 将节点(节点数据是e)添加到表头(header)之前。</span><br><span class="line"> 77         // 即，将节点添加到双向链表的末端。</span><br><span class="line"> 78         addBefore(e, header);</span><br><span class="line"> 79         return true;</span><br><span class="line"> 80     &#125;</span><br><span class="line"> 81 </span><br><span class="line"> 82     // 从LinkedList中删除元素(o)</span><br><span class="line"> 83     // 从链表开始查找，如存在元素(o)则删除该元素并返回true；</span><br><span class="line"> 84     // 否则，返回false。</span><br><span class="line"> 85     public boolean remove(Object o) &#123;</span><br><span class="line"> 86         if (o==null) &#123;</span><br><span class="line"> 87             // 若o为null的删除情况</span><br><span class="line"> 88             for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123;</span><br><span class="line"> 89                 if (e.element==null) &#123;</span><br><span class="line"> 90                     remove(e);</span><br><span class="line"> 91                     return true;</span><br><span class="line"> 92                 &#125;</span><br><span class="line"> 93             &#125;</span><br><span class="line"> 94         &#125; else &#123;</span><br><span class="line"> 95             // 若o不为null的删除情况</span><br><span class="line"> 96             for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123;</span><br><span class="line"> 97                 if (o.equals(e.element)) &#123;</span><br><span class="line"> 98                     remove(e);</span><br><span class="line"> 99                     return true;</span><br><span class="line">100                 &#125;</span><br><span class="line">101             &#125;</span><br><span class="line">102         &#125;</span><br><span class="line">103         return false;</span><br><span class="line">104     &#125;</span><br><span class="line">105 </span><br><span class="line">106     // 将“集合(c)”添加到LinkedList中。</span><br><span class="line">107     // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。</span><br><span class="line">108     public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">109         return addAll(size, c);</span><br><span class="line">110     &#125;</span><br><span class="line">111 </span><br><span class="line">112     // 从双向链表的index开始，将“集合(c)”添加到双向链表中。</span><br><span class="line">113     public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">114         if (index &lt; 0 || index &gt; size)</span><br><span class="line">115             throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span><br><span class="line">116                                                 &quot;, Size: &quot;+size);</span><br><span class="line">117         Object[] a = c.toArray();</span><br><span class="line">118         // 获取集合的长度</span><br><span class="line">119         int numNew = a.length;</span><br><span class="line">120         if (numNew==0)</span><br><span class="line">121             return false;</span><br><span class="line">122         modCount++;</span><br><span class="line">123 </span><br><span class="line">124         // 设置“当前要插入节点的后一个节点”</span><br><span class="line">125         Entry&lt;E&gt; successor = (index==size ? header : entry(index));</span><br><span class="line">126         // 设置“当前要插入节点的前一个节点”</span><br><span class="line">127         Entry&lt;E&gt; predecessor = successor.previous;</span><br><span class="line">128         // 将集合(c)全部插入双向链表中</span><br><span class="line">129         for (int i=0; i&lt;numNew; i++) &#123;</span><br><span class="line">130             Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor);</span><br><span class="line">131             predecessor.next = e;</span><br><span class="line">132             predecessor = e;</span><br><span class="line">133         &#125;</span><br><span class="line">134         successor.previous = predecessor;</span><br><span class="line">135 </span><br><span class="line">136         // 调整LinkedList的实际大小</span><br><span class="line">137         size += numNew;</span><br><span class="line">138         return true;</span><br><span class="line">139     &#125;</span><br><span class="line">140 </span><br><span class="line">141     // 清空双向链表</span><br><span class="line">142     public void clear() &#123;</span><br><span class="line">143         Entry&lt;E&gt; e = header.next;</span><br><span class="line">144         // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作：</span><br><span class="line">145         // (01) 设置前一个节点为null </span><br><span class="line">146         // (02) 设置当前节点的内容为null </span><br><span class="line">147         // (03) 设置后一个节点为“新的当前节点”</span><br><span class="line">148         while (e != header) &#123;</span><br><span class="line">149             Entry&lt;E&gt; next = e.next;</span><br><span class="line">150             e.next = e.previous = null;</span><br><span class="line">151             e.element = null;</span><br><span class="line">152             e = next;</span><br><span class="line">153         &#125;</span><br><span class="line">154         header.next = header.previous = header;</span><br><span class="line">155         // 设置大小为0</span><br><span class="line">156         size = 0;</span><br><span class="line">157         modCount++;</span><br><span class="line">158     &#125;</span><br><span class="line">159 </span><br><span class="line">160     // 返回LinkedList指定位置的元素</span><br><span class="line">161     public E get(int index) &#123;</span><br><span class="line">162         return entry(index).element;</span><br><span class="line">163     &#125;</span><br><span class="line">164 </span><br><span class="line">165     // 设置index位置对应的节点的值为element</span><br><span class="line">166     public E set(int index, E element) &#123;</span><br><span class="line">167         Entry&lt;E&gt; e = entry(index);</span><br><span class="line">168         E oldVal = e.element;</span><br><span class="line">169         e.element = element;</span><br><span class="line">170         return oldVal;</span><br><span class="line">171     &#125;</span><br><span class="line">172  </span><br><span class="line">173     // 在index前添加节点，且节点的值为element</span><br><span class="line">174     public void add(int index, E element) &#123;</span><br><span class="line">175         addBefore(element, (index==size ? header : entry(index)));</span><br><span class="line">176     &#125;</span><br><span class="line">177 </span><br><span class="line">178     // 删除index位置的节点</span><br><span class="line">179     public E remove(int index) &#123;</span><br><span class="line">180         return remove(entry(index));</span><br><span class="line">181     &#125;</span><br><span class="line">182 </span><br><span class="line">183     // 获取双向链表中指定位置的节点</span><br><span class="line">184     private Entry&lt;E&gt; entry(int index) &#123;</span><br><span class="line">185         if (index &lt; 0 || index &gt;= size)</span><br><span class="line">186             throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span><br><span class="line">187                                                 &quot;, Size: &quot;+size);</span><br><span class="line">188         Entry&lt;E&gt; e = header;</span><br><span class="line">189         // 获取index处的节点。</span><br><span class="line">190         // 若index &lt; 双向链表长度的1/2,则从前先后查找;</span><br><span class="line">191         // 否则，从后向前查找。</span><br><span class="line">192         if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">193             for (int i = 0; i &lt;= index; i++)</span><br><span class="line">194                 e = e.next;</span><br><span class="line">195         &#125; else &#123;</span><br><span class="line">196             for (int i = size; i &gt; index; i--)</span><br><span class="line">197                 e = e.previous;</span><br><span class="line">198         &#125;</span><br><span class="line">199         return e;</span><br><span class="line">200     &#125;</span><br><span class="line">201 </span><br><span class="line">202     // 从前向后查找，返回“值为对象(o)的节点对应的索引”</span><br><span class="line">203     // 不存在就返回-1</span><br><span class="line">204     public int indexOf(Object o) &#123;</span><br><span class="line">205         int index = 0;</span><br><span class="line">206         if (o==null) &#123;</span><br><span class="line">207             for (Entry e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">208                 if (e.element==null)</span><br><span class="line">209                     return index;</span><br><span class="line">210                 index++;</span><br><span class="line">211             &#125;</span><br><span class="line">212         &#125; else &#123;</span><br><span class="line">213             for (Entry e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">214                 if (o.equals(e.element))</span><br><span class="line">215                     return index;</span><br><span class="line">216                 index++;</span><br><span class="line">217             &#125;</span><br><span class="line">218         &#125;</span><br><span class="line">219         return -1;</span><br><span class="line">220     &#125;</span><br><span class="line">221 </span><br><span class="line">222     // 从后向前查找，返回“值为对象(o)的节点对应的索引”</span><br><span class="line">223     // 不存在就返回-1</span><br><span class="line">224     public int lastIndexOf(Object o) &#123;</span><br><span class="line">225         int index = size;</span><br><span class="line">226         if (o==null) &#123;</span><br><span class="line">227             for (Entry e = header.previous; e != header; e = e.previous) &#123;</span><br><span class="line">228                 index--;</span><br><span class="line">229                 if (e.element==null)</span><br><span class="line">230                     return index;</span><br><span class="line">231             &#125;</span><br><span class="line">232         &#125; else &#123;</span><br><span class="line">233             for (Entry e = header.previous; e != header; e = e.previous) &#123;</span><br><span class="line">234                 index--;</span><br><span class="line">235                 if (o.equals(e.element))</span><br><span class="line">236                     return index;</span><br><span class="line">237             &#125;</span><br><span class="line">238         &#125;</span><br><span class="line">239         return -1;</span><br><span class="line">240     &#125;</span><br><span class="line">241 </span><br><span class="line">242     // 返回第一个节点</span><br><span class="line">243     // 若LinkedList的大小为0,则返回null</span><br><span class="line">244     public E peek() &#123;</span><br><span class="line">245         if (size==0)</span><br><span class="line">246             return null;</span><br><span class="line">247         return getFirst();</span><br><span class="line">248     &#125;</span><br><span class="line">249 </span><br><span class="line">250     // 返回第一个节点</span><br><span class="line">251     // 若LinkedList的大小为0,则抛出异常</span><br><span class="line">252     public E element() &#123;</span><br><span class="line">253         return getFirst();</span><br><span class="line">254     &#125;</span><br><span class="line">255 </span><br><span class="line">256     // 删除并返回第一个节点</span><br><span class="line">257     // 若LinkedList的大小为0,则返回null</span><br><span class="line">258     public E poll() &#123;</span><br><span class="line">259         if (size==0)</span><br><span class="line">260             return null;</span><br><span class="line">261         return removeFirst();</span><br><span class="line">262     &#125;</span><br><span class="line">263 </span><br><span class="line">264     // 将e添加双向链表末尾</span><br><span class="line">265     public boolean offer(E e) &#123;</span><br><span class="line">266         return add(e);</span><br><span class="line">267     &#125;</span><br><span class="line">268 </span><br><span class="line">269     // 将e添加双向链表开头</span><br><span class="line">270     public boolean offerFirst(E e) &#123;</span><br><span class="line">271         addFirst(e);</span><br><span class="line">272         return true;</span><br><span class="line">273     &#125;</span><br><span class="line">274 </span><br><span class="line">275     // 将e添加双向链表末尾</span><br><span class="line">276     public boolean offerLast(E e) &#123;</span><br><span class="line">277         addLast(e);</span><br><span class="line">278         return true;</span><br><span class="line">279     &#125;</span><br><span class="line">280 </span><br><span class="line">281     // 返回第一个节点</span><br><span class="line">282     // 若LinkedList的大小为0,则返回null</span><br><span class="line">283     public E peekFirst() &#123;</span><br><span class="line">284         if (size==0)</span><br><span class="line">285             return null;</span><br><span class="line">286         return getFirst();</span><br><span class="line">287     &#125;</span><br><span class="line">288 </span><br><span class="line">289     // 返回最后一个节点</span><br><span class="line">290     // 若LinkedList的大小为0,则返回null</span><br><span class="line">291     public E peekLast() &#123;</span><br><span class="line">292         if (size==0)</span><br><span class="line">293             return null;</span><br><span class="line">294         return getLast();</span><br><span class="line">295     &#125;</span><br><span class="line">296 </span><br><span class="line">297     // 删除并返回第一个节点</span><br><span class="line">298     // 若LinkedList的大小为0,则返回null</span><br><span class="line">299     public E pollFirst() &#123;</span><br><span class="line">300         if (size==0)</span><br><span class="line">301             return null;</span><br><span class="line">302         return removeFirst();</span><br><span class="line">303     &#125;</span><br><span class="line">304 </span><br><span class="line">305     // 删除并返回最后一个节点</span><br><span class="line">306     // 若LinkedList的大小为0,则返回null</span><br><span class="line">307     public E pollLast() &#123;</span><br><span class="line">308         if (size==0)</span><br><span class="line">309             return null;</span><br><span class="line">310         return removeLast();</span><br><span class="line">311     &#125;</span><br><span class="line">312 </span><br><span class="line">313     // 将e插入到双向链表开头</span><br><span class="line">314     public void push(E e) &#123;</span><br><span class="line">315         addFirst(e);</span><br><span class="line">316     &#125;</span><br><span class="line">317 </span><br><span class="line">318     // 删除并返回第一个节点</span><br><span class="line">319     public E pop() &#123;</span><br><span class="line">320         return removeFirst();</span><br><span class="line">321     &#125;</span><br><span class="line">322 </span><br><span class="line">323     // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点</span><br><span class="line">324     // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点</span><br><span class="line">325     public boolean removeFirstOccurrence(Object o) &#123;</span><br><span class="line">326         return remove(o);</span><br><span class="line">327     &#125;</span><br><span class="line">328 </span><br><span class="line">329     // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点</span><br><span class="line">330     // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点</span><br><span class="line">331     public boolean removeLastOccurrence(Object o) &#123;</span><br><span class="line">332         if (o==null) &#123;</span><br><span class="line">333             for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123;</span><br><span class="line">334                 if (e.element==null) &#123;</span><br><span class="line">335                     remove(e);</span><br><span class="line">336                     return true;</span><br><span class="line">337                 &#125;</span><br><span class="line">338             &#125;</span><br><span class="line">339         &#125; else &#123;</span><br><span class="line">340             for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123;</span><br><span class="line">341                 if (o.equals(e.element)) &#123;</span><br><span class="line">342                     remove(e);</span><br><span class="line">343                     return true;</span><br><span class="line">344                 &#125;</span><br><span class="line">345             &#125;</span><br><span class="line">346         &#125;</span><br><span class="line">347         return false;</span><br><span class="line">348     &#125;</span><br><span class="line">349 </span><br><span class="line">350     // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器)</span><br><span class="line">351     public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">352         return new ListItr(index);</span><br><span class="line">353     &#125;</span><br><span class="line">354 </span><br><span class="line">355     // List迭代器</span><br><span class="line">356     private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">357         // 上一次返回的节点</span><br><span class="line">358         private Entry&lt;E&gt; lastReturned = header;</span><br><span class="line">359         // 下一个节点</span><br><span class="line">360         private Entry&lt;E&gt; next;</span><br><span class="line">361         // 下一个节点对应的索引值</span><br><span class="line">362         private int nextIndex;</span><br><span class="line">363         // 期望的改变计数。用来实现fail-fast机制。</span><br><span class="line">364         private int expectedModCount = modCount;</span><br><span class="line">365 </span><br><span class="line">366         // 构造函数。</span><br><span class="line">367         // 从index位置开始进行迭代</span><br><span class="line">368         ListItr(int index) &#123;</span><br><span class="line">369             // index的有效性处理</span><br><span class="line">370             if (index &lt; 0 || index &gt; size)</span><br><span class="line">371                 throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size);</span><br><span class="line">372             // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找；</span><br><span class="line">373             // 否则，从最后一个元素往前查找。</span><br><span class="line">374             if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">375                 next = header.next;</span><br><span class="line">376                 for (nextIndex=0; nextIndex&lt;index; nextIndex++)</span><br><span class="line">377                     next = next.next;</span><br><span class="line">378             &#125; else &#123;</span><br><span class="line">379                 next = header;</span><br><span class="line">380                 for (nextIndex=size; nextIndex&gt;index; nextIndex--)</span><br><span class="line">381                     next = next.previous;</span><br><span class="line">382             &#125;</span><br><span class="line">383         &#125;</span><br><span class="line">384 </span><br><span class="line">385         // 是否存在下一个元素</span><br><span class="line">386         public boolean hasNext() &#123;</span><br><span class="line">387             // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。</span><br><span class="line">388             return nextIndex != size;</span><br><span class="line">389         &#125;</span><br><span class="line">390 </span><br><span class="line">391         // 获取下一个元素</span><br><span class="line">392         public E next() &#123;</span><br><span class="line">393             checkForComodification();</span><br><span class="line">394             if (nextIndex == size)</span><br><span class="line">395                 throw new NoSuchElementException();</span><br><span class="line">396 </span><br><span class="line">397             lastReturned = next;</span><br><span class="line">398             // next指向链表的下一个元素</span><br><span class="line">399             next = next.next;</span><br><span class="line">400             nextIndex++;</span><br><span class="line">401             return lastReturned.element;</span><br><span class="line">402         &#125;</span><br><span class="line">403 </span><br><span class="line">404         // 是否存在上一个元素</span><br><span class="line">405         public boolean hasPrevious() &#123;</span><br><span class="line">406             // 通过元素索引是否等于0，来判断是否达到开头。</span><br><span class="line">407             return nextIndex != 0;</span><br><span class="line">408         &#125;</span><br><span class="line">409 </span><br><span class="line">410         // 获取上一个元素</span><br><span class="line">411         public E previous() &#123;</span><br><span class="line">412             if (nextIndex == 0)</span><br><span class="line">413             throw new NoSuchElementException();</span><br><span class="line">414 </span><br><span class="line">415             // next指向链表的上一个元素</span><br><span class="line">416             lastReturned = next = next.previous;</span><br><span class="line">417             nextIndex--;</span><br><span class="line">418             checkForComodification();</span><br><span class="line">419             return lastReturned.element;</span><br><span class="line">420         &#125;</span><br><span class="line">421 </span><br><span class="line">422         // 获取下一个元素的索引</span><br><span class="line">423         public int nextIndex() &#123;</span><br><span class="line">424             return nextIndex;</span><br><span class="line">425         &#125;</span><br><span class="line">426 </span><br><span class="line">427         // 获取上一个元素的索引</span><br><span class="line">428         public int previousIndex() &#123;</span><br><span class="line">429             return nextIndex-1;</span><br><span class="line">430         &#125;</span><br><span class="line">431 </span><br><span class="line">432         // 删除当前元素。</span><br><span class="line">433         // 删除双向链表中的当前节点</span><br><span class="line">434         public void remove() &#123;</span><br><span class="line">435             checkForComodification();</span><br><span class="line">436             Entry&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">437             try &#123;</span><br><span class="line">438                 LinkedList.this.remove(lastReturned);</span><br><span class="line">439             &#125; catch (NoSuchElementException e) &#123;</span><br><span class="line">440                 throw new IllegalStateException();</span><br><span class="line">441             &#125;</span><br><span class="line">442             if (next==lastReturned)</span><br><span class="line">443                 next = lastNext;</span><br><span class="line">444             else</span><br><span class="line">445                 nextIndex--;</span><br><span class="line">446             lastReturned = header;</span><br><span class="line">447             expectedModCount++;</span><br><span class="line">448         &#125;</span><br><span class="line">449 </span><br><span class="line">450         // 设置当前节点为e</span><br><span class="line">451         public void set(E e) &#123;</span><br><span class="line">452             if (lastReturned == header)</span><br><span class="line">453                 throw new IllegalStateException();</span><br><span class="line">454             checkForComodification();</span><br><span class="line">455             lastReturned.element = e;</span><br><span class="line">456         &#125;</span><br><span class="line">457 </span><br><span class="line">458         // 将e添加到当前节点的前面</span><br><span class="line">459         public void add(E e) &#123;</span><br><span class="line">460             checkForComodification();</span><br><span class="line">461             lastReturned = header;</span><br><span class="line">462             addBefore(e, next);</span><br><span class="line">463             nextIndex++;</span><br><span class="line">464             expectedModCount++;</span><br><span class="line">465         &#125;</span><br><span class="line">466 </span><br><span class="line">467         // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。</span><br><span class="line">468         final void checkForComodification() &#123;</span><br><span class="line">469             if (modCount != expectedModCount)</span><br><span class="line">470             throw new ConcurrentModificationException();</span><br><span class="line">471         &#125;</span><br><span class="line">472     &#125;</span><br><span class="line">473 </span><br><span class="line">474     // 双向链表的节点所对应的数据结构。</span><br><span class="line">475     // 包含3部分：上一节点，下一节点，当前节点值。</span><br><span class="line">476     private static class Entry&lt;E&gt; &#123;</span><br><span class="line">477         // 当前节点所包含的值</span><br><span class="line">478         E element;</span><br><span class="line">479         // 下一个节点</span><br><span class="line">480         Entry&lt;E&gt; next;</span><br><span class="line">481         // 上一个节点</span><br><span class="line">482         Entry&lt;E&gt; previous;</span><br><span class="line">483 </span><br><span class="line">484         /**</span><br><span class="line">485          * 链表节点的构造函数。</span><br><span class="line">486          * 参数说明：</span><br><span class="line">487          *   element  —— 节点所包含的数据</span><br><span class="line">488          *   next      —— 下一个节点</span><br><span class="line">489          *   previous —— 上一个节点</span><br><span class="line">490          */</span><br><span class="line">491         Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;</span><br><span class="line">492             this.element = element;</span><br><span class="line">493             this.next = next;</span><br><span class="line">494             this.previous = previous;</span><br><span class="line">495         &#125;</span><br><span class="line">496     &#125;</span><br><span class="line">497 </span><br><span class="line">498     // 将节点(节点数据是e)添加到entry节点之前。</span><br><span class="line">499     private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123;</span><br><span class="line">500         // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e</span><br><span class="line">501         Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);</span><br><span class="line">502         newEntry.previous.next = newEntry;</span><br><span class="line">503         newEntry.next.previous = newEntry;</span><br><span class="line">504         // 修改LinkedList大小</span><br><span class="line">505         size++;</span><br><span class="line">506         // 修改LinkedList的修改统计数：用来实现fail-fast机制。</span><br><span class="line">507         modCount++;</span><br><span class="line">508         return newEntry;</span><br><span class="line">509     &#125;</span><br><span class="line">510 </span><br><span class="line">511     // 将节点从链表中删除</span><br><span class="line">512     private E remove(Entry&lt;E&gt; e) &#123;</span><br><span class="line">513         if (e == header)</span><br><span class="line">514             throw new NoSuchElementException();</span><br><span class="line">515 </span><br><span class="line">516         E result = e.element;</span><br><span class="line">517         e.previous.next = e.next;</span><br><span class="line">518         e.next.previous = e.previous;</span><br><span class="line">519         e.next = e.previous = null;</span><br><span class="line">520         e.element = null;</span><br><span class="line">521         size--;</span><br><span class="line">522         modCount++;</span><br><span class="line">523         return result;</span><br><span class="line">524     &#125;</span><br><span class="line">525 </span><br><span class="line">526     // 反向迭代器</span><br><span class="line">527     public Iterator&lt;E&gt; descendingIterator() &#123;</span><br><span class="line">528         return new DescendingIterator();</span><br><span class="line">529     &#125;</span><br><span class="line">530 </span><br><span class="line">531     // 反向迭代器实现类。</span><br><span class="line">532     private class DescendingIterator implements Iterator &#123;</span><br><span class="line">533         final ListItr itr = new ListItr(size());</span><br><span class="line">534         // 反向迭代器是否下一个元素。</span><br><span class="line">535         // 实际上是判断双向链表的当前节点是否达到开头</span><br><span class="line">536         public boolean hasNext() &#123;</span><br><span class="line">537             return itr.hasPrevious();</span><br><span class="line">538         &#125;</span><br><span class="line">539         // 反向迭代器获取下一个元素。</span><br><span class="line">540         // 实际上是获取双向链表的前一个节点</span><br><span class="line">541         public E next() &#123;</span><br><span class="line">542             return itr.previous();</span><br><span class="line">543         &#125;</span><br><span class="line">544         // 删除当前节点</span><br><span class="line">545         public void remove() &#123;</span><br><span class="line">546             itr.remove();</span><br><span class="line">547         &#125;</span><br><span class="line">548     &#125;</span><br><span class="line">549 </span><br><span class="line">550 </span><br><span class="line">551     // 返回LinkedList的Object[]数组</span><br><span class="line">552     public Object[] toArray() &#123;</span><br><span class="line">553     // 新建Object[]数组</span><br><span class="line">554     Object[] result = new Object[size];</span><br><span class="line">555         int i = 0;</span><br><span class="line">556         // 将链表中所有节点的数据都添加到Object[]数组中</span><br><span class="line">557         for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">558             result[i++] = e.element;</span><br><span class="line">559     return result;</span><br><span class="line">560     &#125;</span><br><span class="line">561 </span><br><span class="line">562     // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型</span><br><span class="line">563     public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">564         // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素)</span><br><span class="line">565         // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。</span><br><span class="line">566         if (a.length &lt; size)</span><br><span class="line">567             a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">568                                 a.getClass().getComponentType(), size);</span><br><span class="line">569         // 将链表中所有节点的数据都添加到数组a中</span><br><span class="line">570         int i = 0;</span><br><span class="line">571         Object[] result = a;</span><br><span class="line">572         for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">573             result[i++] = e.element;</span><br><span class="line">574 </span><br><span class="line">575         if (a.length &gt; size)</span><br><span class="line">576             a[size] = null;</span><br><span class="line">577 </span><br><span class="line">578         return a;</span><br><span class="line">579     &#125;</span><br><span class="line">580 </span><br><span class="line">581 </span><br><span class="line">582     // 克隆函数。返回LinkedList的克隆对象。</span><br><span class="line">583     public Object clone() &#123;</span><br><span class="line">584         LinkedList&lt;E&gt; clone = null;</span><br><span class="line">585         // 克隆一个LinkedList克隆对象</span><br><span class="line">586         try &#123;</span><br><span class="line">587             clone = (LinkedList&lt;E&gt;) super.clone();</span><br><span class="line">588         &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">589             throw new InternalError();</span><br><span class="line">590         &#125;</span><br><span class="line">591 </span><br><span class="line">592         // 新建LinkedList表头节点</span><br><span class="line">593         clone.header = new Entry&lt;E&gt;(null, null, null);</span><br><span class="line">594         clone.header.next = clone.header.previous = clone.header;</span><br><span class="line">595         clone.size = 0;</span><br><span class="line">596         clone.modCount = 0;</span><br><span class="line">597 </span><br><span class="line">598         // 将链表中所有节点的数据都添加到克隆对象中</span><br><span class="line">599         for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">600             clone.add(e.element);</span><br><span class="line">601 </span><br><span class="line">602         return clone;</span><br><span class="line">603     &#125;</span><br><span class="line">604 </span><br><span class="line">605     // java.io.Serializable的写入函数</span><br><span class="line">606     // 将LinkedList的“容量，所有的元素值”都写入到输出流中</span><br><span class="line">607     private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">608         throws java.io.IOException &#123;</span><br><span class="line">609         // Write out any hidden serialization magic</span><br><span class="line">610         s.defaultWriteObject();</span><br><span class="line">611 </span><br><span class="line">612         // 写入“容量”</span><br><span class="line">613         s.writeInt(size);</span><br><span class="line">614 </span><br><span class="line">615         // 将链表中所有节点的数据都写入到输出流中</span><br><span class="line">616         for (Entry e = header.next; e != header; e = e.next)</span><br><span class="line">617             s.writeObject(e.element);</span><br><span class="line">618     &#125;</span><br><span class="line">619 </span><br><span class="line">620     // java.io.Serializable的读取函数：根据写入方式反向读出</span><br><span class="line">621     // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出</span><br><span class="line">622     private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">623         throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">624         // Read in any hidden serialization magic</span><br><span class="line">625         s.defaultReadObject();</span><br><span class="line">626 </span><br><span class="line">627         // 从输入流中读取“容量”</span><br><span class="line">628         int size = s.readInt();</span><br><span class="line">629 </span><br><span class="line">630         // 新建链表表头节点</span><br><span class="line">631         header = new Entry&lt;E&gt;(null, null, null);</span><br><span class="line">632         header.next = header.previous = header;</span><br><span class="line">633 </span><br><span class="line">634         // 从输入流中将“所有的元素值”并逐个添加到链表中</span><br><span class="line">635         for (int i=0; i&lt;size; i++)</span><br><span class="line">636             addBefore((E)s.readObject(), header);</span><br><span class="line">637     &#125;</span><br><span class="line">638 </span><br><span class="line">639 &#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li><p>LinkedList实际上是通过双向链表实现的，它包括了一个很重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：<strong>当前结点所包含的值，上一个结点，下一个结点</strong>。</p>
</li>
<li><p>LinkedList的实现方式中可以发现，不存在LinkedList容量不足的问题。</p>
</li>
<li><p>LinkedList的克隆函数，将所有的元素克隆到一个新的LinkedList对象中</p>
</li>
<li><p>LinkedList实现java.io.Serializable。当写入到输出流时，先写入容量，再依次写入“每一个节点保护的值“，当读出输入流时，先读取”容量“，再依次读取每一个元素。</p>
</li>
<li><p>LinkedList实现了Deque，Deque接口定义了在双端队列两端访问元素的方法，提供插入，移除和检查元素的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       第一个元素（头部）                 最后一个元素（尾部）</span><br><span class="line">        抛出异常        特殊值            抛出异常        特殊值</span><br><span class="line">插入    addFirst(e)    offerFirst(e)    addLast(e)        offerLast(e)</span><br><span class="line">移除    removeFirst()  pollFirst()      removeLast()    pollLast()</span><br><span class="line">检查    getFirst()     peekFirst()      getLast()        peekLast()</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList可以作为FIFO的队列，作为FIFO的队列时，下表的方法等价：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">队列方法       等效方法</span><br><span class="line">add(e)        addLast(e)</span><br><span class="line">offer(e)      offerLast(e)</span><br><span class="line">remove()      removeFirst()</span><br><span class="line">poll()        pollFirst()</span><br><span class="line">element()     getFirst()</span><br><span class="line">peek()        peekFirst()</span><br></pre></td></tr></table></figure>
<ul>
<li>LinkedList可以作为LIFO的栈，作为LIFO的栈时，下表的方法等价：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈方法        等效方法</span><br><span class="line">push(e)      addFirst(e)</span><br><span class="line">pop()        removeFirst()</span><br><span class="line">peek()       peekFirst()</span><br></pre></td></tr></table></figure>
<h2 id="遍历LinkedList的方法"><a href="#遍历LinkedList的方法" class="headerlink" title="遍历LinkedList的方法"></a>遍历LinkedList的方法</h2><ul>
<li>迭代器遍历</li>
<li>快速随机访问遍历LinkedList</li>
<li>通过for循环遍历LinkedList</li>
<li>通过pollFirst()，pollLast()，removeFirst()，removeLast()来遍历LinkedList</li>
</ul>
<p>注意在遍历LinkedList时，使用removeFirst()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取而不删除，应该使用第三种遍历方式。<strong>千万不要使用随机访问去遍历LinkedList</strong>。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/Mysql索引原理及使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/Mysql索引原理及使用/" class="post-title-link" itemprop="url">Mysql InnoDB索引原理与使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 09:04:17" itemprop="dateCreated datePublished" datetime="2019-01-10T09:04:17+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-11 10:46:06" itemprop="dateModified" datetime="2019-01-11T10:46:06+08:00">2019-01-11</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/10/Mysql索引原理及使用/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/10/Mysql索引原理及使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引是一个数据结构，该数据结构存储在磁盘上，其中存储了表中某一列的所有值，即索引是基于数据库表中的某一列上的数据组成，而且这些数据存储在某个数据结构中。</p>
<p>索引优化应该是对查询性能优化最有效的手段，索引能轻易将查询性能提高几个数量级，“最优”的索引有时比一个好的“索引”性能好两个数量级。</p>
<h3 id="没有索引会出现什么状况"><a href="#没有索引会出现什么状况" class="headerlink" title="没有索引会出现什么状况"></a>没有索引会出现什么状况</h3><p>建立一个数据表Employee，该表中有三列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee_Name,Employee_Age,Employee_Address</span><br></pre></td></tr></table></figure>
<p>接下来执行查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Employee <span class="keyword">WHERE</span> Employee_Name = <span class="string">'Jesus'</span></span><br></pre></td></tr></table></figure>
<p>执行这条查询后，数据库系统逐行遍历整张表，对每一行检查Employee_Name是否等于”Jesus”，此时要查找所有名字叫“Jesus”的员工，所以在查找到一条名为”Jesus“的员工记录后，并不能停止查找，这是因为还有其他名叫”Jesus“的员工，此时对于表中的每一条数据，数据库都要进行检查，即进行全表扫描(full table scan)。全表扫描的效率太低，此时加上适当的索引能够加快进行查询的速度，索引从根本上减少了需要扫描的行的数量。</p>
<h3 id="索引使查找速度加快"><a href="#索引使查找速度加快" class="headerlink" title="索引使查找速度加快"></a>索引使查找速度加快</h3><p>比如说，一张表有一亿条数据，要查找其中某一条数据，如果一条条进行匹配，最坏情况下匹配一亿次才能得到结果，即为O(n)时间复杂度，这显然无法接受。但若将这张表转换为平衡树结构（一棵节点非常多的树），假设这棵树有十层，通过10次IO开销即可查找到索引所需数据，速度以指数级别提升，得到了O(log n)的复杂度，其中的n为记录总数，而其对数底数是数分叉的个数，结果即为树的层次数，查询次数由亿降为个位数，此时的索引使数据库查询性能有极大提升。</p>
<h3 id="索引的两面性"><a href="#索引的两面性" class="headerlink" title="索引的两面性"></a>索引的两面性</h3><p>事物都有两面性，索引使数据库查询数据的速度上升，但使写入数据的速度下降，因为索引的平衡树结构必须维持在正确的状态，增加删除修改数据都会改变索引的数据内容从而破坏树结构。在数据改变时，DBMS必须重新梳理索引树结构确保其正确，带来不小的性能开销，所以索引给查询以外的操作带来了副作用。</p>
<h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>在数据库中，B+树索引可以分为聚集索引(clustered index)与辅助索引(secondary index)，聚集索引同辅助索引不同的是叶子节点是否存放着一整行的信息。</p>
<p>InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放，聚集索引即按照每张表的主键构造一棵B+树，叶子节点中存放整张表的行记录数据，此时表在磁盘上的存储结构为树状结构，相当于整个表成为了一个索引，索引组织表中数据也是索引的一部分，每个叶子节点通过一个双向链表来连接。注意每张表只能有一个聚集索引，因为每张表只能有一个主键。主键的关键作用就是将表的数据格式转换为B+树的格式存储。</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/1.jpg" alt=""></p>
<p>树中的所有节点（除了叶子节点）存放的都是键值以及指向数据页的偏移量而不是完整的行记录。下面设id为table表的主键，执行一个sql语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1996</span></span><br></pre></td></tr></table></figure>
<p>首先根据索引定位到1996这个值所在的叶节点，再根据叶节点可以取到id = 1996的数据行，此时的查找效率是比较高的：</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/3.jpg" alt=""></p>
<p>多数情况下，查询优化器倾向于使用聚集索引，因为聚集索引能在B+树的叶子节点上直接找到数据。</p>
<h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>辅助索引（Secondary Index)和聚集索引一样，都是采用B+树作为索引存储的数据结构，索引树结构中各节点值来自表中的索引字段，比如说给一个名为user的表加上索引，则索引就由name字段中的值构成，数据发生改变时，DBMS会一直维护索引结构的正确性。若给表中多个字段加上索引。会出现 多个独立的索引结构，每个辅助索引间不存在关联。</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/2.jpg" alt=""></p>
<p>每次给字段建一个新索引时，字段中的数据被复制一份出来用于生成索引。给表添加索引会更多的占用磁盘的存储空间。</p>
<p>在InnoDB中，辅助索引的书签就是相应行数据的聚集索引键，通过辅助索引来查找数据时，InnoDB会遍历辅助索引而且通过其上叶子节点的指针获得对应主键的值（辅助索引的叶子节点包含索引列的值与主键的值)，比如在一棵高度为三的辅助索引树中查找数据，那么需要对这棵辅助索引树遍历三次找到对应的主键，然后再对聚集索引树进行三次查找，最后找到完整数据行对应的叶子节点，一共需要6次逻辑IO访问得到最终的数据页。下图是一个辅助索引寻找数据的示意图：</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/4.jpg" alt=""></p>
<h3 id="联合索引的使用"><a href="#联合索引的使用" class="headerlink" title="联合索引的使用"></a>联合索引的使用</h3><p>联合索引指对表上的多个列进行索引，联合索引创建方法与单个索引相同，但是其中有多个索引列，例如下表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T(</span><br><span class="line">    a <span class="built_in">INT</span>,</span><br><span class="line">    b <span class="built_in">INT</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (a),</span><br><span class="line">    <span class="keyword">KEY</span> idx_a_b (a,b)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span></span><br></pre></td></tr></table></figure>
<p>联合索引本质上也是一棵B+树，联合索引的键值也是排序的，键值数量大于或等于2，键值也是排序的，就这个例子来说，排序方式即(1,1),(1,2),(2,1),(2,4),(3,1),(3,2)，数据按(a,b)的方式进行了存放。对于单个的a列查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a = xxx</span><br></pre></td></tr></table></figure>
<p>显然可以使用这个(a,b)索引，对于查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a = xxx <span class="keyword">and</span> b = xxx</span><br></pre></td></tr></table></figure>
<p>显然也是可以使用这个联合索引的。但注意对于单独的b列查询SELECT <em> FROM TABLE WHERE b = **</em>，则不可以使用这棵b+树索引。联合索引的第二个好处是对第二个键值进行了排序处理，比如某个情况下要查询某个用户的购物情况，并按照时间进行排序，取出最近三次的购买记录，这时使用联合索引可以避免多一次的排序操作，因为索引本身在叶子节点已经排序了。这里给出一个例子，根据以下代码创建测试表buy_log:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> buy_log (</span><br><span class="line">    userid <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    buy_date <span class="built_in">DATE</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2019-01-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'2019-01-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'2019-01-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2019-02-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'2019-02-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2019-03-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2019-04-11'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> buy_log <span class="keyword">ADD</span> <span class="keyword">KEY</span> (userid);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> buy_log <span class="keyword">ADD</span> <span class="keyword">KEY</span> (userid, buy_date);</span><br></pre></td></tr></table></figure>
<p>以上代码建立两个索引进行比较，两个索引都包含userid字段。若只对userid进行查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> buy_log <span class="keyword">WHERE</span> userid=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>从possible_keys可以看出有两个索引可供使用，分别是单个的userid索引和(userid, buy_date)的联合索引。但是优化器最终的选择是索引userid,因为该索引的叶子节点只包含单个键值，理论上一个页能够存放的记录更多。</p>
<p>再下面想要取出userid为1的最近3次的购买记录，SQL语句如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> buy_log <span class="keyword">WHERE</span> userid = <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> buy_date <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这里使用EXPLAIN关键字，可知优化器使用了联合索引，因为在联合索引中buy_date已经排序好了。根据该联合索引取出数据，无须再对buy_date做一次额外的排序操作。若强制使用userid索引，则在执行计划的Extra选项中可以看到Using filesort，即需要额外的一次排序操作才能完成查询。注意，联合索引(a, b)其实是根据列a,b进行排序，下列语句直接使用联合索引得到结果:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a=xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> b</span><br></pre></td></tr></table></figure>
<p>对于联合索引(a, b, c)来说，下列语句同样可以直接通过联合索引得到结果:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a=xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> b;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a=xxx <span class="keyword">AND</span> b=xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> c;</span><br></pre></td></tr></table></figure>
<p>但是注意，对于下面的语句，联合索引不能直接得到结果，还需要执行一次filesort排序操作，因为索引(a, c)并未排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a=xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> c</span><br></pre></td></tr></table></figure>
<h3 id="覆盖索引的使用"><a href="#覆盖索引的使用" class="headerlink" title="覆盖索引的使用"></a>覆盖索引的使用</h3><p>InnoDB存储引擎支持覆盖索引(covering index)，即从辅助索引中就能够得到查询的记录，而不需要去查询聚集索引中的记录，记住聚集索引(主键)是通往真实数据所在的唯一途径。但覆盖索引是一种例外可以不使用聚集索引就能查询出所需要的数据。注意当为字段建立索引后，字段中的内容被同步至索引中，辅助索引大小远小于聚集索引，因此可以减少大量的IO操作，先看下面这个SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_birthday <span class="keyword">ON</span> user_info(birthday)</span><br></pre></td></tr></table></figure>
<p>查询生日在1996年11月1日出生的用户名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> birthday = <span class="string">'1996-11-01'</span></span><br></pre></td></tr></table></figure>
<p>这句SELECT语句的执行过程如下，首先，通过非聚集索引index_birthday查找birthday为1996-11-01的所有记录的主键ID值，再通过得到的主键ID值进行聚集索引查找，最后从得到的真实数据中取得user_name字段的值返回。</p>
<p>下面我们修改birthday上的索引为一个双字段的覆盖索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_birthday_and_user_name <span class="keyword">ON</span> user_info(birthday, user_name);</span><br></pre></td></tr></table></figure>
<p>这句SELECT语句的执行过程会变成通过辅助索引index_birthday_and_user_name查找birthday为1996-11-01的叶节点内容，此时user_name字段的值也在叶节点中，所以不需要通过主键ID值查找数据行的真实所在，直接取得叶节点中user_name的值返回就可以了，这种覆盖索引查找的方式大大提高了查询性能：</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/5.jpg" alt=""></p>
<p>参考书籍：</p>
<p>高性能Mysql(High Performance MySQL)</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/6.jpg" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/InnoDB关键特性/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/09/InnoDB关键特性/" class="post-title-link" itemprop="url">InnoDB关键特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-09 20:29:14" itemprop="dateCreated datePublished" datetime="2019-01-09T20:29:14+08:00">2019-01-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-11 16:22:57" itemprop="dateModified" datetime="2019-01-11T16:22:57+08:00">2019-01-11</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/09/InnoDB关键特性/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/09/InnoDB关键特性/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="插入缓冲-Insert-Buffer-以及它解决的问题"><a href="#插入缓冲-Insert-Buffer-以及它解决的问题" class="headerlink" title="插入缓冲(Insert Buffer)以及它解决的问题"></a>插入缓冲(Insert Buffer)以及它解决的问题</h3><p> 插入缓冲这个名字可能会让人以为插入缓冲是缓冲池的一个组成部分，其实不然，插入缓冲和数据页一样，都是物理页的一个组成部分，插入缓冲为解决非聚集索引的写性能问题（插入或更新）而设计。对非聚集索引的插入或更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入；不在则先放入到一个Insert Buffer对象中，此时起到了欺骗的效果，看似数据库这个非聚集索引已经插入到了叶子节点，然而并非如此，只是存放在另一个位置。然后再以一定的频率以及情况进行Insert Buffer同辅助索引页子节点的merge操作，此时通常能将多个插入合并到一个操作中，这就大大提高了<strong>非聚集索引插入的性能</strong>。</p>
<p>Insert Buffer的使用要满足以下两个条件：</p>
<ul>
<li>索引是辅助索引</li>
<li>索引不是唯一的</li>
</ul>
<p>满足以上两个条件时使用Insert Buffer，提高插入操作的性能。不过有这样一种情况，即应用程序进行大量的插入操作，这些都涉及了不唯一的非聚集索引，即使用了Insert Buffer。若此时Mysql数据库发生了宕机，肯定有大量的Insert Buffer未合并到实际的非聚集索引中，此时要恢复可能会耗费很长的时间。</p>
<p>目前，Insert Buffer存在一个问题，即写密集的情况下，插入缓冲会占用过多缓冲池内存(innodb_buffer_pool)，默认最大可以占用1/2的缓冲池内存。修改IBUF_POOL_SIZE_PER_MAX_SIZE就可以对插入缓冲的大小进行控制，比如将IBUF_POOL_SIZE_PER_MAX_SIZE改为3，则最大只能使用1/3的缓冲池内存。</p>
<p>现在说说插入缓冲具体是什么，Insert Buffer的数据结构是一棵B+树，现在的MySQL版本中，全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer，而这棵B+树存放在共享表空间中，即ibdata1中。因此通过独立表空间ibd文件恢复表中数据时往往会导致CHECK TABLE失败。因为表辅助索引的数据还在Insert Buffer中，即共享表空间中，通过ibd文件恢复后，还需要进行REPAIR TABLE来重建表上的辅助索引。</p>
<h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>哈希(hash)是一种非常快的查询方法，一般情况下这种查找的时间复杂度为O(1)，一般需要一次查找即可定位数据，而B+树的查询次数，取决于B+树的高度，常需要3到4次的查询。</p>
<p>自适应哈希索引(adaptive hash index)，是InnoDB引擎的一个特殊功能，当InnoDB发现某些索引值使用十分频繁时，它会在内存中基于B-Tree索引上再创建一个哈希索引，这样可以让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。自适应哈希索引是一个完全自动的内部行为，用户无法控制或配置，但是有必要的话可以关闭该功能。</p>
<p>InnoDB存储引擎监控对一个表上各个索引页的查询，若是发现在索引页上建立哈希索引可以带来速度提升，则建立哈希索引，称为自适应哈希索引(AHI)。AHI由缓冲池的B+树页建立哈希索引，建立速度很快，不需要对整张表建立哈希索引。InnoDB存储引擎自动根据访问频率和模式来自动为某些热点页建立哈希索引。</p>
<p>AHI有一个要求，即对这个页的连续访问模式必须是一样的。比如对(a,b)这样的联合索引页，访问模式可以是以下情况：</p>
<ul>
<li><p>WHERE a=xxx</p>
</li>
<li><p>WHERE a=xxx AND b=xxx</p>
</li>
</ul>
<p>访问模式一样指查询条件一样，交替进行上述两种查询的话，则InnoDB存储引擎不会对该页构造AHI。启用AHI后，读取和写入速度可以提高2倍。辅助索引的连接操作性能可以提高5倍。AHI是一种非常好的优化模式，其设计思想为数据库自优化，无需DBA进行人为的调整。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> <span class="keyword">INNODB</span> <span class="keyword">STATUS</span></span><br></pre></td></tr></table></figure>
<p>通过此命令可以看到当前AHI的使用情况。</p>
<p>注意哈希索引只能用来搜索等值的查询，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> index_col=<span class="string">'XXX'</span></span><br></pre></td></tr></table></figure>
<p>对于其他查找类型比如范围查找，不能使用范围索引，因此SHOW ENGINE INNODB STATUS结果中出现了non-hash searches/s的情况。AHI由InnoDB引擎控制，用户只能通过SHOW ENGINE INNODB STATUS的结果以及参数innodb_adaptive_hash_index来考虑是否启用此特性，默认情况下AHI是开启的。</p>
<h3 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h3><p>Insert Buffer和AHI关注InnoDB性能上的提升，而doublewrite(两次写)带给InnoDB的是数据页的可靠性。发生数据库宕机时，InnoDB存储引擎可能正在写入某个页到表中，而这个页只写了一部分，比如说一个16kb的页，只写了前4kb，之后数据库就宕机了，这种情况叫做部分写失效(partial page write)。在InnoDB存储引擎中未使用doublewrite技术前，曾有因为部分写失效导致数据丢失的情况。</p>
<p>doublewrite分为两部分，一部分是内存中的doublewrite buffer，大小2M，另一部分是磁盘上共享表空间的连续128个页，大小也是2M。对缓冲池脏页进行刷新时，先用memcpy函数将脏页复制到内存的doublewrite buffer，然后由doublewrite buffer再分为两次，每次1MB顺序写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘。doublewrite页(共享表空间的页)是连续的，所以这是一个顺序的过程，并没有很大的开销。若操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，复制到表空间文件再应用重做日志。完成共享表空间相关的写入后，再将doublewrite buffer中的页写入各个表空间文件中，而此时的写入则是离散的，因为各个表空间可能在磁盘的不同位置。</p>
<p>如果操作系统在将页写入磁盘的过程中发生了崩溃，恢复过程中，InnoDB可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。</p>
<p>参数skip_innodb_doublewrite可以禁用doublewrite功能，可能导致前面提及的写失效问题，对于需要提供数据高可靠性的主服务器(master server)，任何时候都应该确保开启doublewrite功能。</p>
<p><img src="/2019/01/09/InnoDB关键特性/1.JPG" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">段铭</p>
              <p class="site-description motion-element" itemprop="description">编程随想</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">段铭</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  

  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  




  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
