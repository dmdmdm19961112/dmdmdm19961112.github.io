<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="编程随想">
<meta property="og:type" content="website">
<meta property="og:title" content="sleepyhead沉思录">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="sleepyhead沉思录">
<meta property="og:description" content="编程随想">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sleepyhead沉思录">
<meta name="twitter:description" content="编程随想">






  <link rel="canonical" href="http://yoursite.com/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>sleepyhead沉思录</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sleepyhead沉思录</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">繁荣昌盛，生生不息</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/Mysql中的锁/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/21/Mysql中的锁/" class="post-title-link" itemprop="url">Mysql中的锁</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-21 14:57:24" itemprop="dateCreated datePublished" datetime="2019-01-21T14:57:24+08:00">2019-01-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-03 16:13:49" itemprop="dateModified" datetime="2020-04-03T16:13:49+08:00">2020-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/inmysql/" itemprop="url" rel="index"><span itemprop="name">inmysql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/21/Mysql中的锁/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/21/Mysql中的锁/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mysql中的锁"><a href="#Mysql中的锁" class="headerlink" title="Mysql中的锁"></a>Mysql中的锁</h1><p>我们要开发多用户，数据库驱动的应用，有一个难点是要最大程度利用数据库的并发访问，而且还要确保每个用户能以一致的方式去读取和修改数据。所以就有了锁的机制，这也是数据库系统区分于文件系统的一个关键特性。InnoDB引擎与Mysql的其他存储引擎相比，在此方面更具优势，只有正确了解这些锁的内部机制才能够充分发挥InnoDB引擎在锁方面的优势。</p>
<h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>锁是数据库系统区别于文件系统的一个关键特性，锁机制管理对共享资源的并发访问。<strong>InnoDb存储引擎会在行级别上对表数据上锁</strong>，这是OK的。而且除了表数据以外，InnoDB存储引擎也在数据库内部其他地方使用锁，从而为不同的多种资源提供并发访问。比如操作缓冲池中的LRU列表，删除，添加，移动LRU列表中的元素，为保证一致性，必须要有锁的介入。<strong>数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性与一致性。</strong></p>
<p>在不同数据库之中，锁的实现是多种多样的，SQL语法层面，由于SQL标准的存在，易于熟悉多个关系数据库系统。但是对于锁，用户可能只对特定系统的锁定模型有一定经验。但这不意味着熟悉其他数据库的锁定模型。举例来说，MySQL的InnoDB存储引擎和MyISAM存储引擎对锁的实现完全不同。</p>
<p><strong>MyISAM的锁是表锁设计</strong>，并发情况下的读是没有问题的，但是并发插入的性能就要差一些。而对于SQL Server数据库，在SQL Server2005版本前都是页锁，相对表锁的MyISAM引擎，并发性能是更高的，到2005版本，SQL server开始支持<strong>乐观并发</strong>与<strong>悲观并发</strong>，在乐观并发下开始支持行级锁，但它的实现方式和InnoDB存储引擎的实现方式完全不同，在SQL Server下，锁是一种稀有的资源，锁越多，开销越大，这种情况下会有<strong>锁升级</strong>，行锁会升级到表锁，这时并发性能又回到了以前。</p>
<p>InnoDB存储引擎锁的实现与Oracle很类似，提供一致性的非锁定读，行级锁支持。行级锁没有相关额外的开销，而且可以同时得到并发性和一致性。</p>
<p>MySQL这3种锁的特性可以大致归纳如下：</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大。加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般般</li>
</ul>
<p>很难笼统的说哪种锁更好，只能说哪种锁更合适，从锁的角度来说，表级锁更适合于以查询为主，只有少量更新数据的应用，比如说web应用；而行级锁则更适合有大量更新不同数据，同时又有并发查询的应用，比如一些在线事务处理系统。</p>
<h2 id="Lock与Latch"><a href="#Lock与Latch" class="headerlink" title="Lock与Latch"></a>Lock与Latch</h2><p>数据库中，Lock与Latch都称为锁，但两者截然不同，<strong>这里主要关注lock</strong>。</p>
<p>latch为轻量级的锁，其要求锁定的时间很短，若持续时间长，则应用的性能会非常差，在InnoDB存储引擎中，latch又可以分为mutex和rwlock。目的是保证并发线程操作临界资源的准确性，而且Latch通常没有死锁检测的机制。</p>
<p>而lock的对象为事务，用来<strong>锁定数据库中的对象</strong>，比如<strong>表，行，页</strong>。而且一般lock的对象只在事务commit或rollback后释放。（不同事务隔离级别释放的时间可能不同）。此外，<strong>lock是有死锁机制的</strong>。</p>
<h2 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h2><p>MyISAM存储引擎只支持表锁，在MySQL开始几个版本中，这是唯一支持的锁类型。随着应用对事务完整性和并发性的要求不断提高，MySQL才开始开发基于事务的存储引擎，后来出现了支持页锁的BDB存储引擎和支持行锁的InnoDB存储引擎。但是MyISAM的表锁依然是使用最为广泛的锁类型。这里详细介绍MyISAM表锁的使用。</p>
<h4 id="查询表级锁争用情况"><a href="#查询表级锁争用情况" class="headerlink" title="查询表级锁争用情况"></a>查询表级锁争用情况</h4><p>可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;table%&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/21/Mysql中的锁/1.JPG" alt=""></p>
<p>如果Table_locks_waited的值比较高，则说明存在较严重的表级锁争用情况。</p>
<p>MySQL的表级锁有两种模式：表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)。</p>
<p>锁模式的兼容性如图所示：</p>
<p><img src="/2019/01/21/Mysql中的锁/2.JPG" alt=""></p>
<p>可见对MyISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但是会阻塞对同一个表的写请求；对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；<strong>MyISAM的读操作和写操作之间，以及写操作间是串行的 </strong>!下面的例子展示了，一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读和写操作都会等待，直到锁被释放。</p>
<p><img src="/2019/01/21/Mysql中的锁/3.JPG" alt=""></p>
<h4 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h4><p><strong>MyISAM在执行查询语句之前(SELECT)，会自动给涉及的所有表加读锁，在执行更新操作(DELETE,UPDATE,INSERT)前，会自动给涉及的表加写锁</strong>，这个过程并不需要用户干预，所以用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。上面的显式加锁只是为了方便，实际上并非必须如此。</p>
<p>给MyISAM表显式加锁，一般是为了在一定程度上模拟事务操作，实现某个时间点多个表的一致性读取。比如有一个订单表orders，其中记录有各个订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计subtotal，假设我们需要检查这两个表的金额是否相符，可能需要执行下面两条SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(total) FROM orders;</span><br><span class="line">SELECT SUM(subtotal) FROM order_detail;</span><br></pre></td></tr></table></figure>
<p>这里如果不先给两个表加锁，可能产生错误的结果，因为在第一条语句执行过程中，order_detail表可能已经发生了改变。正确的做法应是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCK tables orders read local, order_detail read local;</span><br><span class="line">SELECT SUM(total) FROM orders;</span><br><span class="line">SELECT SUM(subtotal) FROM order_detail;</span><br><span class="line">UNLOCK tables;</span><br></pre></td></tr></table></figure>
<p>上面的例子在LOCK TABLES时加了”local”选项，其作用是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录。</p>
<p>注意在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表而无法访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作而不能执行更新操作。其实在自动加锁的情况下也是这样，<strong>MyISAM一次获得SQL语句所需要的所有锁 </strong>。所以MyISAM表不会出现死锁(Deaklock Free)。</p>
<p>下面的一个例子中，一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定的表中的记录，但更新或访问其他表都会提示错误；同时另外一个session也可以查询表中的记录，但更新会出现锁等待：</p>
<p><img src="/2019/01/21/Mysql中的锁/4.JPG" alt=""></p>
<p>当使用LOCK TABLES时，<strong>要一次锁定用到的所有表</strong>，而且同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁定多少次，否则也会出错。</p>
<p>举例说明：</p>
<ul>
<li>对actor表获得读锁：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; lock table actor read;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是此时通过别名访问会提示错误</li>
</ul>
<p><img src="/2019/01/21/Mysql中的锁/5.JPG" alt=""></p>
<ul>
<li>为了解决这个问题，需要对别名分别锁定</li>
</ul>
<p><img src="/2019/01/21/Mysql中的锁/C:/blog\source\_posts\Mysql中的锁\6.JPG" alt=""></p>
<ul>
<li>对别名分别锁定后，按照别名的查询可以正确进行</li>
</ul>
<p><img src="/2019/01/21/Mysql中的锁/7.JPG" alt=""></p>
<h4 id="并发插入-Concurrent-Inserts"><a href="#并发插入-Concurrent-Inserts" class="headerlink" title="并发插入(Concurrent Inserts)"></a>并发插入(Concurrent Inserts)</h4><p>上面说MyISAM表的读和写是串行的，这是总体而言的，一定条件下MyISAM表支持查询和插入操作的并发进行</p>
<p>MyISAM存储引擎有一个<strong>系统变量concurrent_insert</strong>，专门控制其并发插入的行为，其值可以为0，1,2。</p>
<ul>
<li>concurrent_insert设置为0时，不允许并发插入</li>
<li>concurrent_insert设置为1时，如果MyISAM表中没有空洞（表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是MySQL的默认设置。</li>
<li>concurrent_insert设置为2时，无论MyISAM表中有无空洞，都允许在表尾并发插入记录</li>
</ul>
<p>如下面的例子中，session_1获得了一个表的READ LOCAL锁，该线程可以对表进行查询操作，但不能对表进行更新操作；其他的线程(session_2)，虽然不能对表进行删除和更新操作，但可以对表进行并发插入操作，这里假设表中不存在空洞：</p>
<p><img src="/2019/01/21/Mysql中的锁/8.JPG" alt=""></p>
<p>可以利用MyISAM的并发插入特性，解决应用中对同一表查询和插入的锁争用。比如将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时执行OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录产生的中间空洞，OPTIMIZE TABLE是一个简单实用的优化方法。</p>
<h4 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h4><p>MyISAM存储引擎的读锁和写锁是互斥的，而读写操作是串行的。则一个进程请求某个MyISAM表的读锁，同时一个进程请求同一表的写锁，<strong>此时写进程先获得锁</strong>，不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前。MySQL认为写请求一般比读请求重要。**所以这是MyISAM表不太适合于有大量更新操作和查询操作的应用的原因，因为大量更新操作会导致查询操作很难获得读锁，从而可能永远阻塞。这种情况可能变得很糟糕，但是可以通过一些设置来调节MyISAM的调度行为。</p>
<ul>
<li>通过指定参数low-priority-updates，使MyISAM默认给予读请求优先的权利。</li>
<li>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该<strong>连接</strong>发出的更新请求优先级降低</li>
<li>通过指定INSERT，UPDATE，DELETE的LOW_PRIORITY属性，降低该语句的优先级</li>
</ul>
<p>这几种方法可以用来解决查询相对重要的应用中读锁等待严重的问题。</p>
<p>上面讨论了写调度机制带来的问题和解决方法。注意一点：一些需要长时间运行的查询操作也会使写进程饿死。所以应用中应该尽量避免出现长时间运行的查询操作。可能的情况下可以通过使用中间表等措施对SQL语句进行一定的分解，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免。尽量安排在数据库空闲时段进行。</p>
<h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><p><strong>InnoDB和MyISAM最大不同有两点</strong>：1.支持事务。2.采用了行级锁。行级锁和表级锁有许多不同之处。事务的引入带来了一些新问题：</p>
<h4 id="事务及其ACID特性"><a href="#事务及其ACID特性" class="headerlink" title="事务及其ACID特性"></a>事务及其ACID特性</h4><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有如下四个特性：</p>
<ul>
<li>原子性：事务是一个原子操作单元，其对数据的修改要么全部执行，要么全部不执行</li>
<li>一致性：在事务开始和完成时，数据必须保持一致状态。所有相关的数据规则必须应用于事务的修改以保持数据的完整性；事务结束时，所有的内部数据结构也必须是正确的。</li>
<li>隔离性：数据库系统提供一定的隔离机制，保证事务在不受外界并发操作影响的“独立”环境执行。事务处理的中间状态对外部不可见。</li>
<li>持久性：事务完成后，对于数据的修改是永久性的，即使重新系统故障也可以保持</li>
</ul>
<p>银行转账是事务的一个典型实例。</p>
<h4 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h4><p>相对于串行处理，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而支持更多用户。但并发事务处理可能带来以下的问题：</p>
<ul>
<li>更新丢失：两个或多个事务选择同一行，基于最初选定的值更新该行时，由于每个事务不知道其他事务的存在。<strong>会发生丢失更新问题</strong>。因为最后的更新覆盖了由其他事务做的更新。</li>
<li>脏读：一个事务正在对一条记录进行修改，在这个事务完成并提交前，这条记录的数据处于不一致状态；这时另一个事务也来读取同一条记录，如果不加控制，<strong>第二个事务读取了这些脏数据，并根据它做进一步处理</strong>，就会产生未提交的数据依赖关系。这种情况叫脏读。</li>
<li>不可重复读：一个事务在读取某些数据后的某个时间，<strong>再次读取以前读过的数据</strong>，却发现其读出的数据已经发生了改变，或某些记录已被删除，这就叫不可重复读。</li>
<li>幻读：一个事务按相同的查询条件重新读取以前检索过的数据却发现<strong>其他事务插入了满足其查询条件的新数据</strong>，这种现象叫“幻读”。</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>上面的并发事务处理带来的问题中，<strong>“更新丢失”应该是完全避免的。但要防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决</strong>，防止更新丢失应该是应用的责任。</p>
<p>而<strong>“脏读”，“不可重复读”，“幻读”其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决</strong>。数据库实现<strong>事务隔离的方式</strong>通常分为以下两种：</p>
<ul>
<li>读取数据前对其加锁，阻止其他事务对数据进行修改。</li>
<li>不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照提供一定级别的一致性读取（语句级或者事务级），从用户的角度看，好像数据库可以提供同一数据的多个版本，这种技术叫多版本并发控制(MVCC)，常称为多版本数据库。</li>
</ul>
<p>一致性读又称为快照读，使用MVCC机制读取undo中已经提交的数据，它的读取是非阻塞的。</p>
<p>数据库的事务隔离越严格，并发副作用越小，但付出代价越大，事务隔离的实质就是使事务在一定程度上串行化进行，这显然与“并发”是矛盾的。显然，<strong>不同的应用对读一致性和事务隔离程度的要求不同</strong>，很多应用对不可重复读和幻读并不敏感，而关心数据并发访问的能力。</p>
<p>为<strong>解决</strong>“隔离”和“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，选择不同的隔离级别来平衡“隔离”和“并发”的关系。下面是这四种隔离级别的特性:</p>
<p><img src="/2019/01/21/Mysql中的锁/C:/blog\source\_posts\Mysql中的锁\9.JPG" alt=""></p>
<p>各具体数据库<strong>不一定</strong>实现了上述的隔离级别，比如Oracle只提供Read Committed和Serializable两个隔离级别，另外还提供自己定义的Read Only隔离级别，SQL Server除了支持上述ISO/ANSI SQL92定义的4个隔离级别外，还提供一个叫“快照”的隔离级别，严格来说它是一个用MVCC实现的Serializable隔离级别。MySQL支持全部4个隔离级别，但具体实现时有一些特点，<strong>比如在一些隔离级别下采用MVCC一致性读</strong>，一些情况下又不是。</p>
<h4 id="分析InnoDB行锁争用情况"><a href="#分析InnoDB行锁争用情况" class="headerlink" title="分析InnoDB行锁争用情况"></a>分析InnoDB行锁争用情况</h4><p>可以通过检查InnoDB_row_lock状态变量分析系统上的行锁的争夺情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;innodb_row_lock%&apos;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/21/Mysql中的锁/10.JPG" alt=""></p>
<p>如果发现锁争用比较严重，比如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors(监视器)来进一步观察发生锁冲突的表，数据行等，并分析锁争用的原因。</p>
<p>具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;</span><br></pre></td></tr></table></figure>
<p>然后可以用下面的语句进行查看：</p>
<p><img src="/2019/01/21/Mysql中的锁/11.JPG" alt=""></p>
<p>监视器可以通过发出下列语句来停止查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;DROP TABLE innodb_monitor;</span><br></pre></td></tr></table></figure>
<p>设置监视器后，在SHOW  INNODB STATUS的显示内容中，会有详细的当前锁等待的信息，包括表名，锁类型，锁定记录的情况等，便于进行进一步的分析和确定。打开监视器后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致.err文件变得异常巨大，所以用户在确定问题后要记得删除监控表从而关闭监视器，或者通过“–console”选项来启动服务器以关闭写日志文件。</p>
<h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><p>InnoDB存储引擎实现如下两种标准的行级锁：</p>
<ul>
<li><strong>共享锁，允许事务读一行数据</strong>(S Lock)</li>
<li><strong>排他锁，允许事务删除或者更新一行数据</strong>(X Lock)</li>
</ul>
<p>如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并未改变行r的数据，这种情况叫锁兼容。若事务T3想获得行r的排他锁，则<strong>必须等待事务T1，T2释放行r上的共享锁</strong>。这种情况叫锁不兼容。X锁和任何的锁都不兼容，而S锁仅与S锁兼容。注意S和X都是行锁333，兼容是指对同一记录锁的兼容性情况。</p>
<p>此外，InnoDB存储引擎支持多粒度锁定，<strong>这种锁定支持事务在行级上的锁和表级上的锁同时存在</strong>，为支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的加锁方式，称为<strong>意向锁</strong>，意向锁是将锁定的对象分为多个层次，这意味着事务希望在更细粒度上进行加锁。</p>
<p>若将上锁的对象看作一棵树，对最下层的对象上锁，也就是对最细粒度的对象上锁，则需要对数据库A，表，页上意向锁IX，最后对记录r上X锁。若任何一部分导致等待，则该操作需要等待粗粒度锁的完成。</p>
<p>InnoDB对意向锁的支持比较简练，其意向锁即为表级别的锁，支持两种意向锁：</p>
<ul>
<li>意向共享锁（IS LOCK），事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li>
<li>意向排他锁（IX LOCK），事务打算给数据行加行排他锁，事务在给一个事务加排他锁前必须取得该表的IX锁。</li>
</ul>
<p><strong>意向锁是InnoDB自动加的，不需用户干预 。</strong></p>
<p>总结一下：</p>
<p>1.对于UPDATE，DELETE，INSERT语句，InnoDB自动给涉及数据集加排他锁（X)。</p>
<p>2.对于普通SELECT语句，InnoDB不会加任何锁。</p>
<p>3.事务可以通过以下语句显式给数据集加共享锁或排他锁</p>
<p>共享锁(S)：<strong>SELECT * FROM table_name WHERE … LOCK IN SHARE MODE;</strong></p>
<p>排他锁(X):   <strong>SELECT * FROM table_name WHERE … FOR UPDATE;</strong></p>
<p>用SELECT … IN SHARE MODE获得共享锁。用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或DELETE操作。</p>
<p>但是如果当前事务也需要对该记录进行更新操作，<strong>很可能造成死锁</strong>，对于锁定行记录后需要进行更新操作的应用，应该通过SELECT … FOR UPDATE方式获得排他锁。</p>
<p><img src="/2019/01/21/Mysql中的锁/12.JPG" alt=""></p>
<p><img src="/2019/01/21/Mysql中的锁/13.JPG" alt=""></p>
<p><img src="/2019/01/21/Mysql中的锁/14.JPG" alt=""></p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p><strong>InnoDB行锁通过给索引上的索引项加锁来实现的</strong>，而Oracle是通过在数据块中对相应数据行加锁来实现的。<strong>InnoDB这种行锁实现方式意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</strong>。</p>
<p><strong>实际应用中要注意InnoDB行锁的这一特性，不然可能导致大量锁冲突从而影响并发性能。</strong></p>
<p>下面通过一些实际例子来进行说明：</p>
<p><strong>例子1</strong>：<strong>在不通过索引条件查询时，InnoDB确实使用的是表锁而不是行锁。</strong></p>
<p>在表20-9所示的例子中，假设开始tab_no_index表没有索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE tab_no_index(id int, name varchar(10)) engine = INNODB;</span><br><span class="line">mysql&gt; insert into tab_no_index values(1,&apos;1&apos;),(2,&apos;2&apos;),(3,&apos;3&apos;),(4,&apos;4&apos;);</span><br></pre></td></tr></table></figure>
<p>表20-9，InnoDB存储引擎的表在不使用索引时使用表锁的例子：</p>
<p><img src="/2019/01/21/Mysql中的锁/15.JPG" alt=""></p>
<p>上面的表中看起来session_1只给一行加了排他锁，但session_2请求其他行的排他锁时，却出现了锁等待。</p>
<p><strong>这是因为在没有索引的情况下，InnoDB只能使用表锁。而当我们给其增加一个索引后，此时InnoDB就只锁定了符合条件的行，如下表20-10所示。</strong></p>
<p>创建tab_with_index表，id字段有一个普通索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE tab_with_index(id int, name varchar(10)) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/12/ArrayList与LinkedList/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/12/ArrayList与LinkedList/" class="post-title-link" itemprop="url">ArrayList与LinkedList详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-12 19:47:30" itemprop="dateCreated datePublished" datetime="2019-01-12T19:47:30+08:00">2019-01-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-05 15:05:16" itemprop="dateModified" datetime="2019-04-05T15:05:16+08:00">2019-04-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java并发编程/" itemprop="url" rel="index"><span itemprop="name">Java并发编程</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/12/ArrayList与LinkedList/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/12/ArrayList与LinkedList/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ArrayList详解"><a href="#ArrayList详解" class="headerlink" title="ArrayList详解"></a>ArrayList详解</h1><h2 id="ArrayList介绍"><a href="#ArrayList介绍" class="headerlink" title="ArrayList介绍"></a>ArrayList介绍</h2><p>ArrayList 是一个<strong>数组队列</strong>，相当于 <strong>动态数组</strong>。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。</p>
<p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。<br>ArrayList 实现了RandmoAccess接口，即提供了<strong>随机访问功能</strong>。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。</p>
<p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>
<p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p>
<p>和Vector不同，<strong>ArrayList中的操作不是线程安全的</strong>！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。</p>
<p> 下面看看ArrayList的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 默认构造函数</span><br><span class="line">ArrayList()</span><br><span class="line"></span><br><span class="line">// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。</span><br><span class="line">ArrayList(int capacity)</span><br><span class="line"></span><br><span class="line">// 创建一个包含collection的ArrayList</span><br><span class="line">ArrayList(Collection&lt;? extends E&gt; collection)</span><br></pre></td></tr></table></figure>
<p>ArrayList的API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Collection中定义的API</span><br><span class="line">boolean             add(E object)</span><br><span class="line">boolean             addAll(Collection&lt;? extends E&gt; collection)</span><br><span class="line">void                clear()</span><br><span class="line">boolean             contains(Object object)</span><br><span class="line">boolean             containsAll(Collection&lt;?&gt; collection)</span><br><span class="line">boolean             equals(Object object)</span><br><span class="line">int                 hashCode()</span><br><span class="line">boolean             isEmpty()</span><br><span class="line">Iterator&lt;E&gt;         iterator()</span><br><span class="line">boolean             remove(Object object)</span><br><span class="line">boolean             removeAll(Collection&lt;?&gt; collection)</span><br><span class="line">boolean             retainAll(Collection&lt;?&gt; collection)</span><br><span class="line">int                 size()</span><br><span class="line">&lt;T&gt; T[]             toArray(T[] array)</span><br><span class="line">Object[]            toArray()</span><br><span class="line">// AbstractCollection中定义的API</span><br><span class="line">void                add(int location, E object)</span><br><span class="line">boolean             addAll(int location, Collection&lt;? extends E&gt; collection)</span><br><span class="line">E                   get(int location)</span><br><span class="line">int                 indexOf(Object object)</span><br><span class="line">int                 lastIndexOf(Object object)</span><br><span class="line">ListIterator&lt;E&gt;     listIterator(int location)</span><br><span class="line">ListIterator&lt;E&gt;     listIterator()</span><br><span class="line">E                   remove(int location)</span><br><span class="line">E                   set(int location, E object)</span><br><span class="line">List&lt;E&gt;             subList(int start, int end)</span><br><span class="line">// ArrayList新增的API</span><br><span class="line">Object               clone()</span><br><span class="line">void                 ensureCapacity(int minimumCapacity)</span><br><span class="line">void                 trimToSize()</span><br><span class="line">void                 removeRange(int fromIndex, int toIndex)</span><br></pre></td></tr></table></figure>
<h2 id="ArrayList内部数据结构"><a href="#ArrayList内部数据结构" class="headerlink" title="ArrayList内部数据结构"></a>ArrayList内部数据结构</h2><p>ArrayList包含了两个重要的对象：elementData 和 size。</p>
<p>(1) elementData 是”Object[]类型的数组”，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是10。elementData数组的大小会根据ArrayList容量的增长而动态的增长，具体的增长方式，请参考源码分析中的ensureCapacity()函数。</p>
<p>(2) size 则是动态数组的实际大小。</p>
<h2 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h2><p>ArrayList通过数组实现，源码比较容易理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line">  1 package java.util;</span><br><span class="line">  2 </span><br><span class="line">  3 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">  4         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">  5 &#123;</span><br><span class="line">  6     // 序列版本号</span><br><span class="line">  7     private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line">  8 </span><br><span class="line">  9     // 保存ArrayList中数据的数组</span><br><span class="line"> 10     private transient Object[] elementData;</span><br><span class="line"> 11 </span><br><span class="line"> 12     // ArrayList中实际数据的数量</span><br><span class="line"> 13     private int size;</span><br><span class="line"> 14 </span><br><span class="line"> 15     // ArrayList带容量大小的构造函数。</span><br><span class="line"> 16     public ArrayList(int initialCapacity) &#123;</span><br><span class="line"> 17         super();</span><br><span class="line"> 18         if (initialCapacity &lt; 0)</span><br><span class="line"> 19             throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line"> 20                                                initialCapacity);</span><br><span class="line"> 21         // 新建一个数组</span><br><span class="line"> 22         this.elementData = new Object[initialCapacity];</span><br><span class="line"> 23     &#125;</span><br><span class="line"> 24 </span><br><span class="line"> 25     // ArrayList构造函数。默认容量是10。</span><br><span class="line"> 26     public ArrayList() &#123;</span><br><span class="line"> 27         this(10);</span><br><span class="line"> 28     &#125;</span><br><span class="line"> 29 </span><br><span class="line"> 30     // 创建一个包含collection的ArrayList</span><br><span class="line"> 31     public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line"> 32         elementData = c.toArray();</span><br><span class="line"> 33         size = elementData.length;</span><br><span class="line"> 34         // c.toArray might (incorrectly) not return Object[] (see        6260652)</span><br><span class="line"> 35         if (elementData.getClass() != Object[].class)</span><br><span class="line"> 36             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line"> 37     &#125;</span><br><span class="line"> 38 </span><br><span class="line"> 39 </span><br><span class="line"> 40     // 将当前容量值设为 =实际元素个数</span><br><span class="line"> 41     public void trimToSize() &#123;</span><br><span class="line"> 42         modCount++;</span><br><span class="line"> 43         int oldCapacity = elementData.length;</span><br><span class="line"> 44         if (size &lt; oldCapacity) &#123;</span><br><span class="line"> 45             elementData = Arrays.copyOf(elementData, size);</span><br><span class="line"> 46         &#125;</span><br><span class="line"> 47     &#125;</span><br><span class="line"> 48 </span><br><span class="line"> 49 </span><br><span class="line"> 50     // 确定ArrarList的容量。</span><br><span class="line"> 51     // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2  + 1”</span><br><span class="line"> 52     public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line"> 53         // 将“修改统计数”+1</span><br><span class="line"> 54         modCount++;</span><br><span class="line"> 55         int oldCapacity = elementData.length;</span><br><span class="line"> 56         // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”</span><br><span class="line"> 57         if (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line"> 58             Object oldData[] = elementData;</span><br><span class="line"> 59             int newCapacity = (oldCapacity * 3)/2 + 1;</span><br><span class="line"> 60             if (newCapacity &lt; minCapacity)</span><br><span class="line"> 61                 newCapacity = minCapacity;</span><br><span class="line"> 62             elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> 63         &#125;</span><br><span class="line"> 64     &#125;</span><br><span class="line"> 65 </span><br><span class="line"> 66     // 添加元素e</span><br><span class="line"> 67     public boolean add(E e) &#123;</span><br><span class="line"> 68         // 确定ArrayList的容量大小</span><br><span class="line"> 69         ensureCapacity(size + 1);  // Increments modCount!!</span><br><span class="line"> 70         // 添加e到ArrayList中</span><br><span class="line"> 71         elementData[size++] = e;</span><br><span class="line"> 72         return true;</span><br><span class="line"> 73     &#125;</span><br><span class="line"> 74 </span><br><span class="line"> 75     // 返回ArrayList的实际大小</span><br><span class="line"> 76     public int size() &#123;</span><br><span class="line"> 77         return size;</span><br><span class="line"> 78     &#125;</span><br><span class="line"> 79 </span><br><span class="line"> 80     // 返回ArrayList是否包含Object(o)</span><br><span class="line"> 81     public boolean contains(Object o) &#123;</span><br><span class="line"> 82         return indexOf(o) &gt;= 0;</span><br><span class="line"> 83     &#125;</span><br><span class="line"> 84 </span><br><span class="line"> 85     // 返回ArrayList是否为空</span><br><span class="line"> 86     public boolean isEmpty() &#123;</span><br><span class="line"> 87         return size == 0;</span><br><span class="line"> 88     &#125;</span><br><span class="line"> 89 </span><br><span class="line"> 90     // 正向查找，返回元素的索引值</span><br><span class="line"> 91     public int indexOf(Object o) &#123;</span><br><span class="line"> 92         if (o == null) &#123;</span><br><span class="line"> 93             for (int i = 0; i &lt; size; i++)</span><br><span class="line"> 94             if (elementData[i]==null)</span><br><span class="line"> 95                 return i;</span><br><span class="line"> 96             &#125; else &#123;</span><br><span class="line"> 97                 for (int i = 0; i &lt; size; i++)</span><br><span class="line"> 98                 if (o.equals(elementData[i]))</span><br><span class="line"> 99                     return i;</span><br><span class="line">100             &#125;</span><br><span class="line">101             return -1;</span><br><span class="line">102         &#125;</span><br><span class="line">103 </span><br><span class="line">104         // 反向查找，返回元素的索引值</span><br><span class="line">105         public int lastIndexOf(Object o) &#123;</span><br><span class="line">106         if (o == null) &#123;</span><br><span class="line">107             for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">108             if (elementData[i]==null)</span><br><span class="line">109                 return i;</span><br><span class="line">110         &#125; else &#123;</span><br><span class="line">111             for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">112             if (o.equals(elementData[i]))</span><br><span class="line">113                 return i;</span><br><span class="line">114         &#125;</span><br><span class="line">115         return -1;</span><br><span class="line">116     &#125;</span><br><span class="line">117 </span><br><span class="line">118     // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值</span><br><span class="line">119     public int lastIndexOf(Object o) &#123;</span><br><span class="line">120         if (o == null) &#123;</span><br><span class="line">121             for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">122             if (elementData[i]==null)</span><br><span class="line">123                 return i;</span><br><span class="line">124         &#125; else &#123;</span><br><span class="line">125             for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">126             if (o.equals(elementData[i]))</span><br><span class="line">127                 return i;</span><br><span class="line">128         &#125;</span><br><span class="line">129         return -1;</span><br><span class="line">130     &#125;</span><br><span class="line">131  </span><br><span class="line">132 </span><br><span class="line">133     // 返回ArrayList的Object数组</span><br><span class="line">134     public Object[] toArray() &#123;</span><br><span class="line">135         return Arrays.copyOf(elementData, size);</span><br><span class="line">136     &#125;</span><br><span class="line">137 </span><br><span class="line">138     // 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型</span><br><span class="line">139     public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">140         // 若数组a的大小 &lt; ArrayList的元素个数；</span><br><span class="line">141         // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中</span><br><span class="line">142         if (a.length &lt; size)</span><br><span class="line">143             return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">144 </span><br><span class="line">145         // 若数组a的大小 &gt;= ArrayList的元素个数；</span><br><span class="line">146         // 则将ArrayList的全部元素都拷贝到数组a中。</span><br><span class="line">147         System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">148         if (a.length &gt; size)</span><br><span class="line">149             a[size] = null;</span><br><span class="line">150         return a;</span><br><span class="line">151     &#125;</span><br><span class="line">152 </span><br><span class="line">153     // 获取index位置的元素值</span><br><span class="line">154     public E get(int index) &#123;</span><br><span class="line">155         RangeCheck(index);</span><br><span class="line">156 </span><br><span class="line">157         return (E) elementData[index];</span><br><span class="line">158     &#125;</span><br><span class="line">159 </span><br><span class="line">160     // 设置index位置的值为element</span><br><span class="line">161     public E set(int index, E element) &#123;</span><br><span class="line">162         RangeCheck(index);</span><br><span class="line">163 </span><br><span class="line">164         E oldValue = (E) elementData[index];</span><br><span class="line">165         elementData[index] = element;</span><br><span class="line">166         return oldValue;</span><br><span class="line">167     &#125;</span><br><span class="line">168 </span><br><span class="line">169     // 将e添加到ArrayList中</span><br><span class="line">170     public boolean add(E e) &#123;</span><br><span class="line">171         ensureCapacity(size + 1);  // Increments modCount!!</span><br><span class="line">172         elementData[size++] = e;</span><br><span class="line">173         return true;</span><br><span class="line">174     &#125;</span><br><span class="line">175 </span><br><span class="line">176     // 将e添加到ArrayList的指定位置</span><br><span class="line">177     public void add(int index, E element) &#123;</span><br><span class="line">178         if (index &gt; size || index &lt; 0)</span><br><span class="line">179             throw new IndexOutOfBoundsException(</span><br><span class="line">180             &quot;Index: &quot;+index+&quot;, Size: &quot;+size);</span><br><span class="line">181 </span><br><span class="line">182         ensureCapacity(size+1);  // Increments modCount!!</span><br><span class="line">183         System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">184              size - index);</span><br><span class="line">185         elementData[index] = element;</span><br><span class="line">186         size++;</span><br><span class="line">187     &#125;</span><br><span class="line">188 </span><br><span class="line">189     // 删除ArrayList指定位置的元素</span><br><span class="line">190     public E remove(int index) &#123;</span><br><span class="line">191         RangeCheck(index);</span><br><span class="line">192 </span><br><span class="line">193         modCount++;</span><br><span class="line">194         E oldValue = (E) elementData[index];</span><br><span class="line">195 </span><br><span class="line">196         int numMoved = size - index - 1;</span><br><span class="line">197         if (numMoved &gt; 0)</span><br><span class="line">198             System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">199                  numMoved);</span><br><span class="line">200         elementData[--size] = null; // Let gc do its work</span><br><span class="line">201 </span><br><span class="line">202         return oldValue;</span><br><span class="line">203     &#125;</span><br><span class="line">204 </span><br><span class="line">205     // 删除ArrayList的指定元素</span><br><span class="line">206     public boolean remove(Object o) &#123;</span><br><span class="line">207         if (o == null) &#123;</span><br><span class="line">208                 for (int index = 0; index &lt; size; index++)</span><br><span class="line">209             if (elementData[index] == null) &#123;</span><br><span class="line">210                 fastRemove(index);</span><br><span class="line">211                 return true;</span><br><span class="line">212             &#125;</span><br><span class="line">213         &#125; else &#123;</span><br><span class="line">214             for (int index = 0; index &lt; size; index++)</span><br><span class="line">215             if (o.equals(elementData[index])) &#123;</span><br><span class="line">216                 fastRemove(index);</span><br><span class="line">217                 return true;</span><br><span class="line">218             &#125;</span><br><span class="line">219         &#125;</span><br><span class="line">220         return false;</span><br><span class="line">221     &#125;</span><br><span class="line">222 </span><br><span class="line">223 </span><br><span class="line">224     // 快速删除第index个元素</span><br><span class="line">225     private void fastRemove(int index) &#123;</span><br><span class="line">226         modCount++;</span><br><span class="line">227         int numMoved = size - index - 1;</span><br><span class="line">228         // 从&quot;index+1&quot;开始，用后面的元素替换前面的元素。</span><br><span class="line">229         if (numMoved &gt; 0)</span><br><span class="line">230             System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">231                              numMoved);</span><br><span class="line">232         // 将最后一个元素设为null</span><br><span class="line">233         elementData[--size] = null; // Let gc do its work</span><br><span class="line">234     &#125;</span><br><span class="line">235 </span><br><span class="line">236     // 删除元素</span><br><span class="line">237     public boolean remove(Object o) &#123;</span><br><span class="line">238         if (o == null) &#123;</span><br><span class="line">239             for (int index = 0; index &lt; size; index++)</span><br><span class="line">240             if (elementData[index] == null) &#123;</span><br><span class="line">241                 fastRemove(index);</span><br><span class="line">242             return true;</span><br><span class="line">243             &#125;</span><br><span class="line">244         &#125; else &#123;</span><br><span class="line">245             // 便利ArrayList，找到“元素o”，则删除，并返回true。</span><br><span class="line">246             for (int index = 0; index &lt; size; index++)</span><br><span class="line">247             if (o.equals(elementData[index])) &#123;</span><br><span class="line">248                 fastRemove(index);</span><br><span class="line">249             return true;</span><br><span class="line">250             &#125;</span><br><span class="line">251         &#125;</span><br><span class="line">252         return false;</span><br><span class="line">253     &#125;</span><br><span class="line">254 </span><br><span class="line">255     // 清空ArrayList，将全部的元素设为null</span><br><span class="line">256     public void clear() &#123;</span><br><span class="line">257         modCount++;</span><br><span class="line">258 </span><br><span class="line">259         for (int i = 0; i &lt; size; i++)</span><br><span class="line">260             elementData[i] = null;</span><br><span class="line">261 </span><br><span class="line">262         size = 0;</span><br><span class="line">263     &#125;</span><br><span class="line">264 </span><br><span class="line">265     // 将集合c追加到ArrayList中</span><br><span class="line">266     public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">267         Object[] a = c.toArray();</span><br><span class="line">268         int numNew = a.length;</span><br><span class="line">269         ensureCapacity(size + numNew);  // Increments modCount</span><br><span class="line">270         System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">271         size += numNew;</span><br><span class="line">272         return numNew != 0;</span><br><span class="line">273     &#125;</span><br><span class="line">274 </span><br><span class="line">275     // 从index位置开始，将集合c添加到ArrayList</span><br><span class="line">276     public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">277         if (index &gt; size || index &lt; 0)</span><br><span class="line">278             throw new IndexOutOfBoundsException(</span><br><span class="line">279             &quot;Index: &quot; + index + &quot;, Size: &quot; + size);</span><br><span class="line">280 </span><br><span class="line">281         Object[] a = c.toArray();</span><br><span class="line">282         int numNew = a.length;</span><br><span class="line">283         ensureCapacity(size + numNew);  // Increments modCount</span><br><span class="line">284 </span><br><span class="line">285         int numMoved = size - index;</span><br><span class="line">286         if (numMoved &gt; 0)</span><br><span class="line">287             System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">288                  numMoved);</span><br><span class="line">289 </span><br><span class="line">290         System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">291         size += numNew;</span><br><span class="line">292         return numNew != 0;</span><br><span class="line">293     &#125;</span><br><span class="line">294 </span><br><span class="line">295     // 删除fromIndex到toIndex之间的全部元素。</span><br><span class="line">296     protected void removeRange(int fromIndex, int toIndex) &#123;</span><br><span class="line">297     modCount++;</span><br><span class="line">298     int numMoved = size - toIndex;</span><br><span class="line">299         System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">300                          numMoved);</span><br><span class="line">301 </span><br><span class="line">302     // Let gc do its work</span><br><span class="line">303     int newSize = size - (toIndex-fromIndex);</span><br><span class="line">304     while (size != newSize)</span><br><span class="line">305         elementData[--size] = null;</span><br><span class="line">306     &#125;</span><br><span class="line">307 </span><br><span class="line">308     private void RangeCheck(int index) &#123;</span><br><span class="line">309     if (index &gt;= size)</span><br><span class="line">310         throw new IndexOutOfBoundsException(</span><br><span class="line">311         &quot;Index: &quot;+index+&quot;, Size: &quot;+size);</span><br><span class="line">312     &#125;</span><br><span class="line">313 </span><br><span class="line">314 </span><br><span class="line">315     // 克隆函数</span><br><span class="line">316     public Object clone() &#123;</span><br><span class="line">317         try &#123;</span><br><span class="line">318             ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();</span><br><span class="line">319             // 将当前ArrayList的全部元素拷贝到v中</span><br><span class="line">320             v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">321             v.modCount = 0;</span><br><span class="line">322             return v;</span><br><span class="line">323         &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">324             // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">325             throw new InternalError();</span><br><span class="line">326         &#125;</span><br><span class="line">327     &#125;</span><br><span class="line">328 </span><br><span class="line">329 </span><br><span class="line">330     // java.io.Serializable的写入函数</span><br><span class="line">331     // 将ArrayList的“容量，所有的元素值”都写入到输出流中</span><br><span class="line">332     private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">333         throws java.io.IOException&#123;</span><br><span class="line">334     // Write out element count, and any hidden stuff</span><br><span class="line">335     int expectedModCount = modCount;</span><br><span class="line">336     s.defaultWriteObject();</span><br><span class="line">337 </span><br><span class="line">338         // 写入“数组的容量”</span><br><span class="line">339         s.writeInt(elementData.length);</span><br><span class="line">340 </span><br><span class="line">341     // 写入“数组的每一个元素”</span><br><span class="line">342     for (int i=0; i&lt;size; i++)</span><br><span class="line">343             s.writeObject(elementData[i]);</span><br><span class="line">344 </span><br><span class="line">345     if (modCount != expectedModCount) &#123;</span><br><span class="line">346             throw new ConcurrentModificationException();</span><br><span class="line">347         &#125;</span><br><span class="line">348 </span><br><span class="line">349     &#125;</span><br><span class="line">350 </span><br><span class="line">351 </span><br><span class="line">352     // java.io.Serializable的读取函数：根据写入方式读出</span><br><span class="line">353     // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出</span><br><span class="line">354     private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">355         throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">356         // Read in size, and any hidden stuff</span><br><span class="line">357         s.defaultReadObject();</span><br><span class="line">358 </span><br><span class="line">359         // 从输入流中读取ArrayList的“容量”</span><br><span class="line">360         int arrayLength = s.readInt();</span><br><span class="line">361         Object[] a = elementData = new Object[arrayLength];</span><br><span class="line">362 </span><br><span class="line">363         // 从输入流中将“所有的元素值”读出</span><br><span class="line">364         for (int i=0; i&lt;size; i++)</span><br><span class="line">365             a[i] = s.readObject();</span><br><span class="line">366     &#125;</span><br><span class="line">367 &#125;</span><br></pre></td></tr></table></figure>
<p>总结源码：</p>
<ul>
<li>ArrayList实际上<strong>通过一个数组去保存数据</strong>，当我们构造ArrayList时；若使用默认构造函数，ArrayList<strong>默认大小为10 </strong>。</li>
<li><p>当ArrayList容量不足以去容纳全部元素时，ArrayList会重新设置容量：<strong>新的容量 = （原始容量*3/2 + 1 </strong>。</p>
</li>
<li><p>ArrayList的克隆函数，即是将全部元素克隆到一个数组中。</p>
</li>
</ul>
<h2 id="ArrayList的遍历方式"><a href="#ArrayList的遍历方式" class="headerlink" title="ArrayList的遍历方式"></a>ArrayList的遍历方式</h2><ul>
<li>迭代器遍历</li>
<li>随机访问，通过索引值遍历</li>
<li>for循环遍历</li>
</ul>
<p><strong>遍历ArrayList时，使用随机访问（通过索引序号访问）效率最高，而使用迭代器效率最低。</strong></p>
<h1 id="LinkedList详解"><a href="#LinkedList详解" class="headerlink" title="LinkedList详解"></a>LinkedList详解</h1><h2 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h2><p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。<br>LinkedList 实现 List 接口，能对它进行队列操作。<br>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。<br>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。<br>LinkedList 是非同步的。</p>
<h2 id="Linkedlist的API"><a href="#Linkedlist的API" class="headerlink" title="Linkedlist的API"></a>Linkedlist的API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">LinkedList的API</span><br><span class="line">boolean       add(E object)</span><br><span class="line">void          add(int location, E object)</span><br><span class="line">boolean       addAll(Collection&lt;? extends E&gt; collection)</span><br><span class="line">boolean       addAll(int location, Collection&lt;? extends E&gt; collection)</span><br><span class="line">void          addFirst(E object)</span><br><span class="line">void          addLast(E object)</span><br><span class="line">void          clear()</span><br><span class="line">Object        clone()</span><br><span class="line">boolean       contains(Object object)</span><br><span class="line">Iterator&lt;E&gt;   descendingIterator()</span><br><span class="line">E             element()</span><br><span class="line">E             get(int location)</span><br><span class="line">E             getFirst()</span><br><span class="line">E             getLast()</span><br><span class="line">int           indexOf(Object object)</span><br><span class="line">int           lastIndexOf(Object object)</span><br><span class="line">ListIterator&lt;E&gt;     listIterator(int location)</span><br><span class="line">boolean       offer(E o)</span><br><span class="line">boolean       offerFirst(E e)</span><br><span class="line">boolean       offerLast(E e)</span><br><span class="line">E             peek()</span><br><span class="line">E             peekFirst()</span><br><span class="line">E             peekLast()</span><br><span class="line">E             poll()</span><br><span class="line">E             pollFirst()</span><br><span class="line">E             pollLast()</span><br><span class="line">E             pop()</span><br><span class="line">void          push(E e)</span><br><span class="line">E             remove()</span><br><span class="line">E             remove(int location)</span><br><span class="line">boolean       remove(Object object)</span><br><span class="line">E             removeFirst()</span><br><span class="line">boolean       removeFirstOccurrence(Object o)</span><br><span class="line">E             removeLast()</span><br><span class="line">boolean       removeLastOccurrence(Object o)</span><br><span class="line">E             set(int location, E object)</span><br><span class="line">int           size()</span><br><span class="line">&lt;T&gt; T[]       toArray(T[] contents)</span><br><span class="line">Object[]     toArray()</span><br></pre></td></tr></table></figure>
<h2 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h2><p>为了更了解LinkedList的原理，<strong>下面对LinkedList源码代码作出分析</strong>。</p>
<p>在阅读源码之前，我们先对LinkedList的整体实现进行大致说明：<br>   LinkedList实际上是通过双向链表去实现的。既然是双向链表，那么它的<strong>顺序访问会非常高效，而随机访问效率比较低</strong>。<br>​    既然LinkedList是通过双向链表的，但是它也实现了List接口{也就是说，它实现了get(int location)、remove(int location)等 “根据索引值来获取、删除节点的函数”}。LinkedList是如何实现List的这些接口的，如何将“双向链表和索引值联系起来的”？<br>​    实际原理非常简单，它就是通过一个<strong>计数索引值</strong>来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置。<br>   这就是“双线链表和索引值联系起来”的方法。</p>
<p>好了，接下来开始阅读源码(只要理解双向链表，那么LinkedList的源码很容易理解的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br></pre></td><td class="code"><pre><span class="line">1 package java.util;</span><br><span class="line">  2 </span><br><span class="line">  3 public class LinkedList&lt;E&gt;</span><br><span class="line">  4     extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">  5     implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">  6 &#123;</span><br><span class="line">  7     // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。</span><br><span class="line">  8     private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null);</span><br><span class="line">  9 </span><br><span class="line"> 10     // LinkedList中元素个数</span><br><span class="line"> 11     private transient int size = 0;</span><br><span class="line"> 12 </span><br><span class="line"> 13     // 默认构造函数：创建一个空的链表</span><br><span class="line"> 14     public LinkedList() &#123;</span><br><span class="line"> 15         header.next = header.previous = header;</span><br><span class="line"> 16     &#125;</span><br><span class="line"> 17 </span><br><span class="line"> 18     // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList</span><br><span class="line"> 19     public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line"> 20         this();</span><br><span class="line"> 21         addAll(c);</span><br><span class="line"> 22     &#125;</span><br><span class="line"> 23 </span><br><span class="line"> 24     // 获取LinkedList的第一个元素</span><br><span class="line"> 25     public E getFirst() &#123;</span><br><span class="line"> 26         if (size==0)</span><br><span class="line"> 27             throw new NoSuchElementException();</span><br><span class="line"> 28 </span><br><span class="line"> 29         // 链表的表头header中不包含数据。</span><br><span class="line"> 30         // 这里返回header所指下一个节点所包含的数据。</span><br><span class="line"> 31         return header.next.element;</span><br><span class="line"> 32     &#125;</span><br><span class="line"> 33 </span><br><span class="line"> 34     // 获取LinkedList的最后一个元素</span><br><span class="line"> 35     public E getLast()  &#123;</span><br><span class="line"> 36         if (size==0)</span><br><span class="line"> 37             throw new NoSuchElementException();</span><br><span class="line"> 38 </span><br><span class="line"> 39         // 由于LinkedList是双向链表；而表头header不包含数据。</span><br><span class="line"> 40         // 因而，这里返回表头header的前一个节点所包含的数据。</span><br><span class="line"> 41         return header.previous.element;</span><br><span class="line"> 42     &#125;</span><br><span class="line"> 43 </span><br><span class="line"> 44     // 删除LinkedList的第一个元素</span><br><span class="line"> 45     public E removeFirst() &#123;</span><br><span class="line"> 46         return remove(header.next);</span><br><span class="line"> 47     &#125;</span><br><span class="line"> 48 </span><br><span class="line"> 49     // 删除LinkedList的最后一个元素</span><br><span class="line"> 50     public E removeLast() &#123;</span><br><span class="line"> 51         return remove(header.previous);</span><br><span class="line"> 52     &#125;</span><br><span class="line"> 53 </span><br><span class="line"> 54     // 将元素添加到LinkedList的起始位置</span><br><span class="line"> 55     public void addFirst(E e) &#123;</span><br><span class="line"> 56         addBefore(e, header.next);</span><br><span class="line"> 57     &#125;</span><br><span class="line"> 58 </span><br><span class="line"> 59     // 将元素添加到LinkedList的结束位置</span><br><span class="line"> 60     public void addLast(E e) &#123;</span><br><span class="line"> 61         addBefore(e, header);</span><br><span class="line"> 62     &#125;</span><br><span class="line"> 63 </span><br><span class="line"> 64     // 判断LinkedList是否包含元素(o)</span><br><span class="line"> 65     public boolean contains(Object o) &#123;</span><br><span class="line"> 66         return indexOf(o) != -1;</span><br><span class="line"> 67     &#125;</span><br><span class="line"> 68 </span><br><span class="line"> 69     // 返回LinkedList的大小</span><br><span class="line"> 70     public int size() &#123;</span><br><span class="line"> 71         return size;</span><br><span class="line"> 72     &#125;</span><br><span class="line"> 73 </span><br><span class="line"> 74     // 将元素(E)添加到LinkedList中</span><br><span class="line"> 75     public boolean add(E e) &#123;</span><br><span class="line"> 76         // 将节点(节点数据是e)添加到表头(header)之前。</span><br><span class="line"> 77         // 即，将节点添加到双向链表的末端。</span><br><span class="line"> 78         addBefore(e, header);</span><br><span class="line"> 79         return true;</span><br><span class="line"> 80     &#125;</span><br><span class="line"> 81 </span><br><span class="line"> 82     // 从LinkedList中删除元素(o)</span><br><span class="line"> 83     // 从链表开始查找，如存在元素(o)则删除该元素并返回true；</span><br><span class="line"> 84     // 否则，返回false。</span><br><span class="line"> 85     public boolean remove(Object o) &#123;</span><br><span class="line"> 86         if (o==null) &#123;</span><br><span class="line"> 87             // 若o为null的删除情况</span><br><span class="line"> 88             for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123;</span><br><span class="line"> 89                 if (e.element==null) &#123;</span><br><span class="line"> 90                     remove(e);</span><br><span class="line"> 91                     return true;</span><br><span class="line"> 92                 &#125;</span><br><span class="line"> 93             &#125;</span><br><span class="line"> 94         &#125; else &#123;</span><br><span class="line"> 95             // 若o不为null的删除情况</span><br><span class="line"> 96             for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123;</span><br><span class="line"> 97                 if (o.equals(e.element)) &#123;</span><br><span class="line"> 98                     remove(e);</span><br><span class="line"> 99                     return true;</span><br><span class="line">100                 &#125;</span><br><span class="line">101             &#125;</span><br><span class="line">102         &#125;</span><br><span class="line">103         return false;</span><br><span class="line">104     &#125;</span><br><span class="line">105 </span><br><span class="line">106     // 将“集合(c)”添加到LinkedList中。</span><br><span class="line">107     // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。</span><br><span class="line">108     public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">109         return addAll(size, c);</span><br><span class="line">110     &#125;</span><br><span class="line">111 </span><br><span class="line">112     // 从双向链表的index开始，将“集合(c)”添加到双向链表中。</span><br><span class="line">113     public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">114         if (index &lt; 0 || index &gt; size)</span><br><span class="line">115             throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span><br><span class="line">116                                                 &quot;, Size: &quot;+size);</span><br><span class="line">117         Object[] a = c.toArray();</span><br><span class="line">118         // 获取集合的长度</span><br><span class="line">119         int numNew = a.length;</span><br><span class="line">120         if (numNew==0)</span><br><span class="line">121             return false;</span><br><span class="line">122         modCount++;</span><br><span class="line">123 </span><br><span class="line">124         // 设置“当前要插入节点的后一个节点”</span><br><span class="line">125         Entry&lt;E&gt; successor = (index==size ? header : entry(index));</span><br><span class="line">126         // 设置“当前要插入节点的前一个节点”</span><br><span class="line">127         Entry&lt;E&gt; predecessor = successor.previous;</span><br><span class="line">128         // 将集合(c)全部插入双向链表中</span><br><span class="line">129         for (int i=0; i&lt;numNew; i++) &#123;</span><br><span class="line">130             Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor);</span><br><span class="line">131             predecessor.next = e;</span><br><span class="line">132             predecessor = e;</span><br><span class="line">133         &#125;</span><br><span class="line">134         successor.previous = predecessor;</span><br><span class="line">135 </span><br><span class="line">136         // 调整LinkedList的实际大小</span><br><span class="line">137         size += numNew;</span><br><span class="line">138         return true;</span><br><span class="line">139     &#125;</span><br><span class="line">140 </span><br><span class="line">141     // 清空双向链表</span><br><span class="line">142     public void clear() &#123;</span><br><span class="line">143         Entry&lt;E&gt; e = header.next;</span><br><span class="line">144         // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作：</span><br><span class="line">145         // (01) 设置前一个节点为null </span><br><span class="line">146         // (02) 设置当前节点的内容为null </span><br><span class="line">147         // (03) 设置后一个节点为“新的当前节点”</span><br><span class="line">148         while (e != header) &#123;</span><br><span class="line">149             Entry&lt;E&gt; next = e.next;</span><br><span class="line">150             e.next = e.previous = null;</span><br><span class="line">151             e.element = null;</span><br><span class="line">152             e = next;</span><br><span class="line">153         &#125;</span><br><span class="line">154         header.next = header.previous = header;</span><br><span class="line">155         // 设置大小为0</span><br><span class="line">156         size = 0;</span><br><span class="line">157         modCount++;</span><br><span class="line">158     &#125;</span><br><span class="line">159 </span><br><span class="line">160     // 返回LinkedList指定位置的元素</span><br><span class="line">161     public E get(int index) &#123;</span><br><span class="line">162         return entry(index).element;</span><br><span class="line">163     &#125;</span><br><span class="line">164 </span><br><span class="line">165     // 设置index位置对应的节点的值为element</span><br><span class="line">166     public E set(int index, E element) &#123;</span><br><span class="line">167         Entry&lt;E&gt; e = entry(index);</span><br><span class="line">168         E oldVal = e.element;</span><br><span class="line">169         e.element = element;</span><br><span class="line">170         return oldVal;</span><br><span class="line">171     &#125;</span><br><span class="line">172  </span><br><span class="line">173     // 在index前添加节点，且节点的值为element</span><br><span class="line">174     public void add(int index, E element) &#123;</span><br><span class="line">175         addBefore(element, (index==size ? header : entry(index)));</span><br><span class="line">176     &#125;</span><br><span class="line">177 </span><br><span class="line">178     // 删除index位置的节点</span><br><span class="line">179     public E remove(int index) &#123;</span><br><span class="line">180         return remove(entry(index));</span><br><span class="line">181     &#125;</span><br><span class="line">182 </span><br><span class="line">183     // 获取双向链表中指定位置的节点</span><br><span class="line">184     private Entry&lt;E&gt; entry(int index) &#123;</span><br><span class="line">185         if (index &lt; 0 || index &gt;= size)</span><br><span class="line">186             throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span><br><span class="line">187                                                 &quot;, Size: &quot;+size);</span><br><span class="line">188         Entry&lt;E&gt; e = header;</span><br><span class="line">189         // 获取index处的节点。</span><br><span class="line">190         // 若index &lt; 双向链表长度的1/2,则从前先后查找;</span><br><span class="line">191         // 否则，从后向前查找。</span><br><span class="line">192         if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">193             for (int i = 0; i &lt;= index; i++)</span><br><span class="line">194                 e = e.next;</span><br><span class="line">195         &#125; else &#123;</span><br><span class="line">196             for (int i = size; i &gt; index; i--)</span><br><span class="line">197                 e = e.previous;</span><br><span class="line">198         &#125;</span><br><span class="line">199         return e;</span><br><span class="line">200     &#125;</span><br><span class="line">201 </span><br><span class="line">202     // 从前向后查找，返回“值为对象(o)的节点对应的索引”</span><br><span class="line">203     // 不存在就返回-1</span><br><span class="line">204     public int indexOf(Object o) &#123;</span><br><span class="line">205         int index = 0;</span><br><span class="line">206         if (o==null) &#123;</span><br><span class="line">207             for (Entry e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">208                 if (e.element==null)</span><br><span class="line">209                     return index;</span><br><span class="line">210                 index++;</span><br><span class="line">211             &#125;</span><br><span class="line">212         &#125; else &#123;</span><br><span class="line">213             for (Entry e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">214                 if (o.equals(e.element))</span><br><span class="line">215                     return index;</span><br><span class="line">216                 index++;</span><br><span class="line">217             &#125;</span><br><span class="line">218         &#125;</span><br><span class="line">219         return -1;</span><br><span class="line">220     &#125;</span><br><span class="line">221 </span><br><span class="line">222     // 从后向前查找，返回“值为对象(o)的节点对应的索引”</span><br><span class="line">223     // 不存在就返回-1</span><br><span class="line">224     public int lastIndexOf(Object o) &#123;</span><br><span class="line">225         int index = size;</span><br><span class="line">226         if (o==null) &#123;</span><br><span class="line">227             for (Entry e = header.previous; e != header; e = e.previous) &#123;</span><br><span class="line">228                 index--;</span><br><span class="line">229                 if (e.element==null)</span><br><span class="line">230                     return index;</span><br><span class="line">231             &#125;</span><br><span class="line">232         &#125; else &#123;</span><br><span class="line">233             for (Entry e = header.previous; e != header; e = e.previous) &#123;</span><br><span class="line">234                 index--;</span><br><span class="line">235                 if (o.equals(e.element))</span><br><span class="line">236                     return index;</span><br><span class="line">237             &#125;</span><br><span class="line">238         &#125;</span><br><span class="line">239         return -1;</span><br><span class="line">240     &#125;</span><br><span class="line">241 </span><br><span class="line">242     // 返回第一个节点</span><br><span class="line">243     // 若LinkedList的大小为0,则返回null</span><br><span class="line">244     public E peek() &#123;</span><br><span class="line">245         if (size==0)</span><br><span class="line">246             return null;</span><br><span class="line">247         return getFirst();</span><br><span class="line">248     &#125;</span><br><span class="line">249 </span><br><span class="line">250     // 返回第一个节点</span><br><span class="line">251     // 若LinkedList的大小为0,则抛出异常</span><br><span class="line">252     public E element() &#123;</span><br><span class="line">253         return getFirst();</span><br><span class="line">254     &#125;</span><br><span class="line">255 </span><br><span class="line">256     // 删除并返回第一个节点</span><br><span class="line">257     // 若LinkedList的大小为0,则返回null</span><br><span class="line">258     public E poll() &#123;</span><br><span class="line">259         if (size==0)</span><br><span class="line">260             return null;</span><br><span class="line">261         return removeFirst();</span><br><span class="line">262     &#125;</span><br><span class="line">263 </span><br><span class="line">264     // 将e添加双向链表末尾</span><br><span class="line">265     public boolean offer(E e) &#123;</span><br><span class="line">266         return add(e);</span><br><span class="line">267     &#125;</span><br><span class="line">268 </span><br><span class="line">269     // 将e添加双向链表开头</span><br><span class="line">270     public boolean offerFirst(E e) &#123;</span><br><span class="line">271         addFirst(e);</span><br><span class="line">272         return true;</span><br><span class="line">273     &#125;</span><br><span class="line">274 </span><br><span class="line">275     // 将e添加双向链表末尾</span><br><span class="line">276     public boolean offerLast(E e) &#123;</span><br><span class="line">277         addLast(e);</span><br><span class="line">278         return true;</span><br><span class="line">279     &#125;</span><br><span class="line">280 </span><br><span class="line">281     // 返回第一个节点</span><br><span class="line">282     // 若LinkedList的大小为0,则返回null</span><br><span class="line">283     public E peekFirst() &#123;</span><br><span class="line">284         if (size==0)</span><br><span class="line">285             return null;</span><br><span class="line">286         return getFirst();</span><br><span class="line">287     &#125;</span><br><span class="line">288 </span><br><span class="line">289     // 返回最后一个节点</span><br><span class="line">290     // 若LinkedList的大小为0,则返回null</span><br><span class="line">291     public E peekLast() &#123;</span><br><span class="line">292         if (size==0)</span><br><span class="line">293             return null;</span><br><span class="line">294         return getLast();</span><br><span class="line">295     &#125;</span><br><span class="line">296 </span><br><span class="line">297     // 删除并返回第一个节点</span><br><span class="line">298     // 若LinkedList的大小为0,则返回null</span><br><span class="line">299     public E pollFirst() &#123;</span><br><span class="line">300         if (size==0)</span><br><span class="line">301             return null;</span><br><span class="line">302         return removeFirst();</span><br><span class="line">303     &#125;</span><br><span class="line">304 </span><br><span class="line">305     // 删除并返回最后一个节点</span><br><span class="line">306     // 若LinkedList的大小为0,则返回null</span><br><span class="line">307     public E pollLast() &#123;</span><br><span class="line">308         if (size==0)</span><br><span class="line">309             return null;</span><br><span class="line">310         return removeLast();</span><br><span class="line">311     &#125;</span><br><span class="line">312 </span><br><span class="line">313     // 将e插入到双向链表开头</span><br><span class="line">314     public void push(E e) &#123;</span><br><span class="line">315         addFirst(e);</span><br><span class="line">316     &#125;</span><br><span class="line">317 </span><br><span class="line">318     // 删除并返回第一个节点</span><br><span class="line">319     public E pop() &#123;</span><br><span class="line">320         return removeFirst();</span><br><span class="line">321     &#125;</span><br><span class="line">322 </span><br><span class="line">323     // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点</span><br><span class="line">324     // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点</span><br><span class="line">325     public boolean removeFirstOccurrence(Object o) &#123;</span><br><span class="line">326         return remove(o);</span><br><span class="line">327     &#125;</span><br><span class="line">328 </span><br><span class="line">329     // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点</span><br><span class="line">330     // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点</span><br><span class="line">331     public boolean removeLastOccurrence(Object o) &#123;</span><br><span class="line">332         if (o==null) &#123;</span><br><span class="line">333             for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123;</span><br><span class="line">334                 if (e.element==null) &#123;</span><br><span class="line">335                     remove(e);</span><br><span class="line">336                     return true;</span><br><span class="line">337                 &#125;</span><br><span class="line">338             &#125;</span><br><span class="line">339         &#125; else &#123;</span><br><span class="line">340             for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123;</span><br><span class="line">341                 if (o.equals(e.element)) &#123;</span><br><span class="line">342                     remove(e);</span><br><span class="line">343                     return true;</span><br><span class="line">344                 &#125;</span><br><span class="line">345             &#125;</span><br><span class="line">346         &#125;</span><br><span class="line">347         return false;</span><br><span class="line">348     &#125;</span><br><span class="line">349 </span><br><span class="line">350     // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器)</span><br><span class="line">351     public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">352         return new ListItr(index);</span><br><span class="line">353     &#125;</span><br><span class="line">354 </span><br><span class="line">355     // List迭代器</span><br><span class="line">356     private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">357         // 上一次返回的节点</span><br><span class="line">358         private Entry&lt;E&gt; lastReturned = header;</span><br><span class="line">359         // 下一个节点</span><br><span class="line">360         private Entry&lt;E&gt; next;</span><br><span class="line">361         // 下一个节点对应的索引值</span><br><span class="line">362         private int nextIndex;</span><br><span class="line">363         // 期望的改变计数。用来实现fail-fast机制。</span><br><span class="line">364         private int expectedModCount = modCount;</span><br><span class="line">365 </span><br><span class="line">366         // 构造函数。</span><br><span class="line">367         // 从index位置开始进行迭代</span><br><span class="line">368         ListItr(int index) &#123;</span><br><span class="line">369             // index的有效性处理</span><br><span class="line">370             if (index &lt; 0 || index &gt; size)</span><br><span class="line">371                 throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size);</span><br><span class="line">372             // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找；</span><br><span class="line">373             // 否则，从最后一个元素往前查找。</span><br><span class="line">374             if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">375                 next = header.next;</span><br><span class="line">376                 for (nextIndex=0; nextIndex&lt;index; nextIndex++)</span><br><span class="line">377                     next = next.next;</span><br><span class="line">378             &#125; else &#123;</span><br><span class="line">379                 next = header;</span><br><span class="line">380                 for (nextIndex=size; nextIndex&gt;index; nextIndex--)</span><br><span class="line">381                     next = next.previous;</span><br><span class="line">382             &#125;</span><br><span class="line">383         &#125;</span><br><span class="line">384 </span><br><span class="line">385         // 是否存在下一个元素</span><br><span class="line">386         public boolean hasNext() &#123;</span><br><span class="line">387             // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。</span><br><span class="line">388             return nextIndex != size;</span><br><span class="line">389         &#125;</span><br><span class="line">390 </span><br><span class="line">391         // 获取下一个元素</span><br><span class="line">392         public E next() &#123;</span><br><span class="line">393             checkForComodification();</span><br><span class="line">394             if (nextIndex == size)</span><br><span class="line">395                 throw new NoSuchElementException();</span><br><span class="line">396 </span><br><span class="line">397             lastReturned = next;</span><br><span class="line">398             // next指向链表的下一个元素</span><br><span class="line">399             next = next.next;</span><br><span class="line">400             nextIndex++;</span><br><span class="line">401             return lastReturned.element;</span><br><span class="line">402         &#125;</span><br><span class="line">403 </span><br><span class="line">404         // 是否存在上一个元素</span><br><span class="line">405         public boolean hasPrevious() &#123;</span><br><span class="line">406             // 通过元素索引是否等于0，来判断是否达到开头。</span><br><span class="line">407             return nextIndex != 0;</span><br><span class="line">408         &#125;</span><br><span class="line">409 </span><br><span class="line">410         // 获取上一个元素</span><br><span class="line">411         public E previous() &#123;</span><br><span class="line">412             if (nextIndex == 0)</span><br><span class="line">413             throw new NoSuchElementException();</span><br><span class="line">414 </span><br><span class="line">415             // next指向链表的上一个元素</span><br><span class="line">416             lastReturned = next = next.previous;</span><br><span class="line">417             nextIndex--;</span><br><span class="line">418             checkForComodification();</span><br><span class="line">419             return lastReturned.element;</span><br><span class="line">420         &#125;</span><br><span class="line">421 </span><br><span class="line">422         // 获取下一个元素的索引</span><br><span class="line">423         public int nextIndex() &#123;</span><br><span class="line">424             return nextIndex;</span><br><span class="line">425         &#125;</span><br><span class="line">426 </span><br><span class="line">427         // 获取上一个元素的索引</span><br><span class="line">428         public int previousIndex() &#123;</span><br><span class="line">429             return nextIndex-1;</span><br><span class="line">430         &#125;</span><br><span class="line">431 </span><br><span class="line">432         // 删除当前元素。</span><br><span class="line">433         // 删除双向链表中的当前节点</span><br><span class="line">434         public void remove() &#123;</span><br><span class="line">435             checkForComodification();</span><br><span class="line">436             Entry&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">437             try &#123;</span><br><span class="line">438                 LinkedList.this.remove(lastReturned);</span><br><span class="line">439             &#125; catch (NoSuchElementException e) &#123;</span><br><span class="line">440                 throw new IllegalStateException();</span><br><span class="line">441             &#125;</span><br><span class="line">442             if (next==lastReturned)</span><br><span class="line">443                 next = lastNext;</span><br><span class="line">444             else</span><br><span class="line">445                 nextIndex--;</span><br><span class="line">446             lastReturned = header;</span><br><span class="line">447             expectedModCount++;</span><br><span class="line">448         &#125;</span><br><span class="line">449 </span><br><span class="line">450         // 设置当前节点为e</span><br><span class="line">451         public void set(E e) &#123;</span><br><span class="line">452             if (lastReturned == header)</span><br><span class="line">453                 throw new IllegalStateException();</span><br><span class="line">454             checkForComodification();</span><br><span class="line">455             lastReturned.element = e;</span><br><span class="line">456         &#125;</span><br><span class="line">457 </span><br><span class="line">458         // 将e添加到当前节点的前面</span><br><span class="line">459         public void add(E e) &#123;</span><br><span class="line">460             checkForComodification();</span><br><span class="line">461             lastReturned = header;</span><br><span class="line">462             addBefore(e, next);</span><br><span class="line">463             nextIndex++;</span><br><span class="line">464             expectedModCount++;</span><br><span class="line">465         &#125;</span><br><span class="line">466 </span><br><span class="line">467         // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。</span><br><span class="line">468         final void checkForComodification() &#123;</span><br><span class="line">469             if (modCount != expectedModCount)</span><br><span class="line">470             throw new ConcurrentModificationException();</span><br><span class="line">471         &#125;</span><br><span class="line">472     &#125;</span><br><span class="line">473 </span><br><span class="line">474     // 双向链表的节点所对应的数据结构。</span><br><span class="line">475     // 包含3部分：上一节点，下一节点，当前节点值。</span><br><span class="line">476     private static class Entry&lt;E&gt; &#123;</span><br><span class="line">477         // 当前节点所包含的值</span><br><span class="line">478         E element;</span><br><span class="line">479         // 下一个节点</span><br><span class="line">480         Entry&lt;E&gt; next;</span><br><span class="line">481         // 上一个节点</span><br><span class="line">482         Entry&lt;E&gt; previous;</span><br><span class="line">483 </span><br><span class="line">484         /**</span><br><span class="line">485          * 链表节点的构造函数。</span><br><span class="line">486          * 参数说明：</span><br><span class="line">487          *   element  —— 节点所包含的数据</span><br><span class="line">488          *   next      —— 下一个节点</span><br><span class="line">489          *   previous —— 上一个节点</span><br><span class="line">490          */</span><br><span class="line">491         Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;</span><br><span class="line">492             this.element = element;</span><br><span class="line">493             this.next = next;</span><br><span class="line">494             this.previous = previous;</span><br><span class="line">495         &#125;</span><br><span class="line">496     &#125;</span><br><span class="line">497 </span><br><span class="line">498     // 将节点(节点数据是e)添加到entry节点之前。</span><br><span class="line">499     private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123;</span><br><span class="line">500         // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e</span><br><span class="line">501         Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);</span><br><span class="line">502         newEntry.previous.next = newEntry;</span><br><span class="line">503         newEntry.next.previous = newEntry;</span><br><span class="line">504         // 修改LinkedList大小</span><br><span class="line">505         size++;</span><br><span class="line">506         // 修改LinkedList的修改统计数：用来实现fail-fast机制。</span><br><span class="line">507         modCount++;</span><br><span class="line">508         return newEntry;</span><br><span class="line">509     &#125;</span><br><span class="line">510 </span><br><span class="line">511     // 将节点从链表中删除</span><br><span class="line">512     private E remove(Entry&lt;E&gt; e) &#123;</span><br><span class="line">513         if (e == header)</span><br><span class="line">514             throw new NoSuchElementException();</span><br><span class="line">515 </span><br><span class="line">516         E result = e.element;</span><br><span class="line">517         e.previous.next = e.next;</span><br><span class="line">518         e.next.previous = e.previous;</span><br><span class="line">519         e.next = e.previous = null;</span><br><span class="line">520         e.element = null;</span><br><span class="line">521         size--;</span><br><span class="line">522         modCount++;</span><br><span class="line">523         return result;</span><br><span class="line">524     &#125;</span><br><span class="line">525 </span><br><span class="line">526     // 反向迭代器</span><br><span class="line">527     public Iterator&lt;E&gt; descendingIterator() &#123;</span><br><span class="line">528         return new DescendingIterator();</span><br><span class="line">529     &#125;</span><br><span class="line">530 </span><br><span class="line">531     // 反向迭代器实现类。</span><br><span class="line">532     private class DescendingIterator implements Iterator &#123;</span><br><span class="line">533         final ListItr itr = new ListItr(size());</span><br><span class="line">534         // 反向迭代器是否下一个元素。</span><br><span class="line">535         // 实际上是判断双向链表的当前节点是否达到开头</span><br><span class="line">536         public boolean hasNext() &#123;</span><br><span class="line">537             return itr.hasPrevious();</span><br><span class="line">538         &#125;</span><br><span class="line">539         // 反向迭代器获取下一个元素。</span><br><span class="line">540         // 实际上是获取双向链表的前一个节点</span><br><span class="line">541         public E next() &#123;</span><br><span class="line">542             return itr.previous();</span><br><span class="line">543         &#125;</span><br><span class="line">544         // 删除当前节点</span><br><span class="line">545         public void remove() &#123;</span><br><span class="line">546             itr.remove();</span><br><span class="line">547         &#125;</span><br><span class="line">548     &#125;</span><br><span class="line">549 </span><br><span class="line">550 </span><br><span class="line">551     // 返回LinkedList的Object[]数组</span><br><span class="line">552     public Object[] toArray() &#123;</span><br><span class="line">553     // 新建Object[]数组</span><br><span class="line">554     Object[] result = new Object[size];</span><br><span class="line">555         int i = 0;</span><br><span class="line">556         // 将链表中所有节点的数据都添加到Object[]数组中</span><br><span class="line">557         for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">558             result[i++] = e.element;</span><br><span class="line">559     return result;</span><br><span class="line">560     &#125;</span><br><span class="line">561 </span><br><span class="line">562     // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型</span><br><span class="line">563     public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">564         // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素)</span><br><span class="line">565         // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。</span><br><span class="line">566         if (a.length &lt; size)</span><br><span class="line">567             a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">568                                 a.getClass().getComponentType(), size);</span><br><span class="line">569         // 将链表中所有节点的数据都添加到数组a中</span><br><span class="line">570         int i = 0;</span><br><span class="line">571         Object[] result = a;</span><br><span class="line">572         for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">573             result[i++] = e.element;</span><br><span class="line">574 </span><br><span class="line">575         if (a.length &gt; size)</span><br><span class="line">576             a[size] = null;</span><br><span class="line">577 </span><br><span class="line">578         return a;</span><br><span class="line">579     &#125;</span><br><span class="line">580 </span><br><span class="line">581 </span><br><span class="line">582     // 克隆函数。返回LinkedList的克隆对象。</span><br><span class="line">583     public Object clone() &#123;</span><br><span class="line">584         LinkedList&lt;E&gt; clone = null;</span><br><span class="line">585         // 克隆一个LinkedList克隆对象</span><br><span class="line">586         try &#123;</span><br><span class="line">587             clone = (LinkedList&lt;E&gt;) super.clone();</span><br><span class="line">588         &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">589             throw new InternalError();</span><br><span class="line">590         &#125;</span><br><span class="line">591 </span><br><span class="line">592         // 新建LinkedList表头节点</span><br><span class="line">593         clone.header = new Entry&lt;E&gt;(null, null, null);</span><br><span class="line">594         clone.header.next = clone.header.previous = clone.header;</span><br><span class="line">595         clone.size = 0;</span><br><span class="line">596         clone.modCount = 0;</span><br><span class="line">597 </span><br><span class="line">598         // 将链表中所有节点的数据都添加到克隆对象中</span><br><span class="line">599         for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">600             clone.add(e.element);</span><br><span class="line">601 </span><br><span class="line">602         return clone;</span><br><span class="line">603     &#125;</span><br><span class="line">604 </span><br><span class="line">605     // java.io.Serializable的写入函数</span><br><span class="line">606     // 将LinkedList的“容量，所有的元素值”都写入到输出流中</span><br><span class="line">607     private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">608         throws java.io.IOException &#123;</span><br><span class="line">609         // Write out any hidden serialization magic</span><br><span class="line">610         s.defaultWriteObject();</span><br><span class="line">611 </span><br><span class="line">612         // 写入“容量”</span><br><span class="line">613         s.writeInt(size);</span><br><span class="line">614 </span><br><span class="line">615         // 将链表中所有节点的数据都写入到输出流中</span><br><span class="line">616         for (Entry e = header.next; e != header; e = e.next)</span><br><span class="line">617             s.writeObject(e.element);</span><br><span class="line">618     &#125;</span><br><span class="line">619 </span><br><span class="line">620     // java.io.Serializable的读取函数：根据写入方式反向读出</span><br><span class="line">621     // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出</span><br><span class="line">622     private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">623         throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">624         // Read in any hidden serialization magic</span><br><span class="line">625         s.defaultReadObject();</span><br><span class="line">626 </span><br><span class="line">627         // 从输入流中读取“容量”</span><br><span class="line">628         int size = s.readInt();</span><br><span class="line">629 </span><br><span class="line">630         // 新建链表表头节点</span><br><span class="line">631         header = new Entry&lt;E&gt;(null, null, null);</span><br><span class="line">632         header.next = header.previous = header;</span><br><span class="line">633 </span><br><span class="line">634         // 从输入流中将“所有的元素值”并逐个添加到链表中</span><br><span class="line">635         for (int i=0; i&lt;size; i++)</span><br><span class="line">636             addBefore((E)s.readObject(), header);</span><br><span class="line">637     &#125;</span><br><span class="line">638 </span><br><span class="line">639 &#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li><p>LinkedList实际上是通过双向链表实现的，它包括了一个很重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：<strong>当前结点所包含的值，上一个结点，下一个结点</strong>。</p>
</li>
<li><p>LinkedList的实现方式中可以发现，不存在LinkedList容量不足的问题。</p>
</li>
<li><p>LinkedList的克隆函数，将所有的元素克隆到一个新的LinkedList对象中</p>
</li>
<li><p>LinkedList实现java.io.Serializable。当写入到输出流时，先写入容量，再依次写入“每一个节点保护的值“，当读出输入流时，先读取”容量“，再依次读取每一个元素。</p>
</li>
<li><p>LinkedList实现了Deque，Deque接口定义了在双端队列两端访问元素的方法，提供插入，移除和检查元素的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       第一个元素（头部）                 最后一个元素（尾部）</span><br><span class="line">        抛出异常        特殊值            抛出异常        特殊值</span><br><span class="line">插入    addFirst(e)    offerFirst(e)    addLast(e)        offerLast(e)</span><br><span class="line">移除    removeFirst()  pollFirst()      removeLast()    pollLast()</span><br><span class="line">检查    getFirst()     peekFirst()      getLast()        peekLast()</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList可以作为FIFO的队列，作为FIFO的队列时，下表的方法等价：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">队列方法       等效方法</span><br><span class="line">add(e)        addLast(e)</span><br><span class="line">offer(e)      offerLast(e)</span><br><span class="line">remove()      removeFirst()</span><br><span class="line">poll()        pollFirst()</span><br><span class="line">element()     getFirst()</span><br><span class="line">peek()        peekFirst()</span><br></pre></td></tr></table></figure>
<ul>
<li>LinkedList可以作为LIFO的栈，作为LIFO的栈时，下表的方法等价：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈方法        等效方法</span><br><span class="line">push(e)      addFirst(e)</span><br><span class="line">pop()        removeFirst()</span><br><span class="line">peek()       peekFirst()</span><br></pre></td></tr></table></figure>
<h2 id="遍历LinkedList的方法"><a href="#遍历LinkedList的方法" class="headerlink" title="遍历LinkedList的方法"></a>遍历LinkedList的方法</h2><ul>
<li>迭代器遍历</li>
<li>快速随机访问遍历LinkedList</li>
<li>通过for循环遍历LinkedList</li>
<li>通过pollFirst()，pollLast()，removeFirst()，removeLast()来遍历LinkedList</li>
</ul>
<p>注意在遍历LinkedList时，使用removeFirst()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取而不删除，应该使用第三种遍历方式。<strong>千万不要使用随机访问去遍历LinkedList</strong>。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/Mysql索引原理及使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/Mysql索引原理及使用/" class="post-title-link" itemprop="url">Mysql InnoDB索引原理与使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 09:04:17" itemprop="dateCreated datePublished" datetime="2019-01-10T09:04:17+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-11 10:46:06" itemprop="dateModified" datetime="2019-01-11T10:46:06+08:00">2019-01-11</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/10/Mysql索引原理及使用/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/10/Mysql索引原理及使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引是一个数据结构，该数据结构存储在磁盘上，其中存储了表中某一列的所有值，即索引是基于数据库表中的某一列上的数据组成，而且这些数据存储在某个数据结构中。</p>
<p>索引优化应该是对查询性能优化最有效的手段，索引能轻易将查询性能提高几个数量级，“最优”的索引有时比一个好的“索引”性能好两个数量级。</p>
<h3 id="没有索引会出现什么状况"><a href="#没有索引会出现什么状况" class="headerlink" title="没有索引会出现什么状况"></a>没有索引会出现什么状况</h3><p>建立一个数据表Employee，该表中有三列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee_Name,Employee_Age,Employee_Address</span><br></pre></td></tr></table></figure>
<p>接下来执行查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Employee <span class="keyword">WHERE</span> Employee_Name = <span class="string">'Jesus'</span></span><br></pre></td></tr></table></figure>
<p>执行这条查询后，数据库系统逐行遍历整张表，对每一行检查Employee_Name是否等于”Jesus”，此时要查找所有名字叫“Jesus”的员工，所以在查找到一条名为”Jesus“的员工记录后，并不能停止查找，这是因为还有其他名叫”Jesus“的员工，此时对于表中的每一条数据，数据库都要进行检查，即进行全表扫描(full table scan)。全表扫描的效率太低，此时加上适当的索引能够加快进行查询的速度，索引从根本上减少了需要扫描的行的数量。</p>
<h3 id="索引使查找速度加快"><a href="#索引使查找速度加快" class="headerlink" title="索引使查找速度加快"></a>索引使查找速度加快</h3><p>比如说，一张表有一亿条数据，要查找其中某一条数据，如果一条条进行匹配，最坏情况下匹配一亿次才能得到结果，即为O(n)时间复杂度，这显然无法接受。但若将这张表转换为平衡树结构（一棵节点非常多的树），假设这棵树有十层，通过10次IO开销即可查找到索引所需数据，速度以指数级别提升，得到了O(log n)的复杂度，其中的n为记录总数，而其对数底数是数分叉的个数，结果即为树的层次数，查询次数由亿降为个位数，此时的索引使数据库查询性能有极大提升。</p>
<h3 id="索引的两面性"><a href="#索引的两面性" class="headerlink" title="索引的两面性"></a>索引的两面性</h3><p>事物都有两面性，索引使数据库查询数据的速度上升，但使写入数据的速度下降，因为索引的平衡树结构必须维持在正确的状态，增加删除修改数据都会改变索引的数据内容从而破坏树结构。在数据改变时，DBMS必须重新梳理索引树结构确保其正确，带来不小的性能开销，所以索引给查询以外的操作带来了副作用。</p>
<h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>在数据库中，B+树索引可以分为聚集索引(clustered index)与辅助索引(secondary index)，聚集索引同辅助索引不同的是叶子节点是否存放着一整行的信息。</p>
<p>InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放，聚集索引即按照每张表的主键构造一棵B+树，叶子节点中存放整张表的行记录数据，此时表在磁盘上的存储结构为树状结构，相当于整个表成为了一个索引，索引组织表中数据也是索引的一部分，每个叶子节点通过一个双向链表来连接。注意每张表只能有一个聚集索引，因为每张表只能有一个主键。主键的关键作用就是将表的数据格式转换为B+树的格式存储。</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/1.jpg" alt=""></p>
<p>树中的所有节点（除了叶子节点）存放的都是键值以及指向数据页的偏移量而不是完整的行记录。下面设id为table表的主键，执行一个sql语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1996</span></span><br></pre></td></tr></table></figure>
<p>首先根据索引定位到1996这个值所在的叶节点，再根据叶节点可以取到id = 1996的数据行，此时的查找效率是比较高的：</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/3.jpg" alt=""></p>
<p>多数情况下，查询优化器倾向于使用聚集索引，因为聚集索引能在B+树的叶子节点上直接找到数据。</p>
<h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>辅助索引（Secondary Index)和聚集索引一样，都是采用B+树作为索引存储的数据结构，索引树结构中各节点值来自表中的索引字段，比如说给一个名为user的表加上索引，则索引就由name字段中的值构成，数据发生改变时，DBMS会一直维护索引结构的正确性。若给表中多个字段加上索引。会出现 多个独立的索引结构，每个辅助索引间不存在关联。</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/2.jpg" alt=""></p>
<p>每次给字段建一个新索引时，字段中的数据被复制一份出来用于生成索引。给表添加索引会更多的占用磁盘的存储空间。</p>
<p>在InnoDB中，辅助索引的书签就是相应行数据的聚集索引键，通过辅助索引来查找数据时，InnoDB会遍历辅助索引而且通过其上叶子节点的指针获得对应主键的值（辅助索引的叶子节点包含索引列的值与主键的值)，比如在一棵高度为三的辅助索引树中查找数据，那么需要对这棵辅助索引树遍历三次找到对应的主键，然后再对聚集索引树进行三次查找，最后找到完整数据行对应的叶子节点，一共需要6次逻辑IO访问得到最终的数据页。下图是一个辅助索引寻找数据的示意图：</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/4.jpg" alt=""></p>
<h3 id="联合索引的使用"><a href="#联合索引的使用" class="headerlink" title="联合索引的使用"></a>联合索引的使用</h3><p>联合索引指对表上的多个列进行索引，联合索引创建方法与单个索引相同，但是其中有多个索引列，例如下表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T(</span><br><span class="line">    a <span class="built_in">INT</span>,</span><br><span class="line">    b <span class="built_in">INT</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (a),</span><br><span class="line">    <span class="keyword">KEY</span> idx_a_b (a,b)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span></span><br></pre></td></tr></table></figure>
<p>联合索引本质上也是一棵B+树，联合索引的键值也是排序的，键值数量大于或等于2，键值也是排序的，就这个例子来说，排序方式即(1,1),(1,2),(2,1),(2,4),(3,1),(3,2)，数据按(a,b)的方式进行了存放。对于单个的a列查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a = xxx</span><br></pre></td></tr></table></figure>
<p>显然可以使用这个(a,b)索引，对于查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a = xxx <span class="keyword">and</span> b = xxx</span><br></pre></td></tr></table></figure>
<p>显然也是可以使用这个联合索引的。但注意对于单独的b列查询SELECT <em> FROM TABLE WHERE b = **</em>，则不可以使用这棵b+树索引。联合索引的第二个好处是对第二个键值进行了排序处理，比如某个情况下要查询某个用户的购物情况，并按照时间进行排序，取出最近三次的购买记录，这时使用联合索引可以避免多一次的排序操作，因为索引本身在叶子节点已经排序了。这里给出一个例子，根据以下代码创建测试表buy_log:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> buy_log (</span><br><span class="line">    userid <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    buy_date <span class="built_in">DATE</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2019-01-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'2019-01-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'2019-01-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2019-02-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'2019-02-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2019-03-11'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> buy_log <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'2019-04-11'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> buy_log <span class="keyword">ADD</span> <span class="keyword">KEY</span> (userid);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> buy_log <span class="keyword">ADD</span> <span class="keyword">KEY</span> (userid, buy_date);</span><br></pre></td></tr></table></figure>
<p>以上代码建立两个索引进行比较，两个索引都包含userid字段。若只对userid进行查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> buy_log <span class="keyword">WHERE</span> userid=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>从possible_keys可以看出有两个索引可供使用，分别是单个的userid索引和(userid, buy_date)的联合索引。但是优化器最终的选择是索引userid,因为该索引的叶子节点只包含单个键值，理论上一个页能够存放的记录更多。</p>
<p>再下面想要取出userid为1的最近3次的购买记录，SQL语句如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> buy_log <span class="keyword">WHERE</span> userid = <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> buy_date <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这里使用EXPLAIN关键字，可知优化器使用了联合索引，因为在联合索引中buy_date已经排序好了。根据该联合索引取出数据，无须再对buy_date做一次额外的排序操作。若强制使用userid索引，则在执行计划的Extra选项中可以看到Using filesort，即需要额外的一次排序操作才能完成查询。注意，联合索引(a, b)其实是根据列a,b进行排序，下列语句直接使用联合索引得到结果:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a=xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> b</span><br></pre></td></tr></table></figure>
<p>对于联合索引(a, b, c)来说，下列语句同样可以直接通过联合索引得到结果:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a=xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> b;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a=xxx <span class="keyword">AND</span> b=xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> c;</span><br></pre></td></tr></table></figure>
<p>但是注意，对于下面的语句，联合索引不能直接得到结果，还需要执行一次filesort排序操作，因为索引(a, c)并未排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a=xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> c</span><br></pre></td></tr></table></figure>
<h3 id="覆盖索引的使用"><a href="#覆盖索引的使用" class="headerlink" title="覆盖索引的使用"></a>覆盖索引的使用</h3><p>InnoDB存储引擎支持覆盖索引(covering index)，即从辅助索引中就能够得到查询的记录，而不需要去查询聚集索引中的记录，记住聚集索引(主键)是通往真实数据所在的唯一途径。但覆盖索引是一种例外可以不使用聚集索引就能查询出所需要的数据。注意当为字段建立索引后，字段中的内容被同步至索引中，辅助索引大小远小于聚集索引，因此可以减少大量的IO操作，先看下面这个SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_birthday <span class="keyword">ON</span> user_info(birthday)</span><br></pre></td></tr></table></figure>
<p>查询生日在1996年11月1日出生的用户名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> birthday = <span class="string">'1996-11-01'</span></span><br></pre></td></tr></table></figure>
<p>这句SELECT语句的执行过程如下，首先，通过非聚集索引index_birthday查找birthday为1996-11-01的所有记录的主键ID值，再通过得到的主键ID值进行聚集索引查找，最后从得到的真实数据中取得user_name字段的值返回。</p>
<p>下面我们修改birthday上的索引为一个双字段的覆盖索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_birthday_and_user_name <span class="keyword">ON</span> user_info(birthday, user_name);</span><br></pre></td></tr></table></figure>
<p>这句SELECT语句的执行过程会变成通过辅助索引index_birthday_and_user_name查找birthday为1996-11-01的叶节点内容，此时user_name字段的值也在叶节点中，所以不需要通过主键ID值查找数据行的真实所在，直接取得叶节点中user_name的值返回就可以了，这种覆盖索引查找的方式大大提高了查询性能：</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/5.jpg" alt=""></p>
<p>参考书籍：</p>
<p>高性能Mysql(High Performance MySQL)</p>
<p><img src="/2019/01/10/Mysql索引原理及使用/6.jpg" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/InnoDB关键特性/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="段铭">
      <meta itemprop="description" content="编程随想">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sleepyhead沉思录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/09/InnoDB关键特性/" class="post-title-link" itemprop="url">InnoDB关键特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-09 20:29:14" itemprop="dateCreated datePublished" datetime="2019-01-09T20:29:14+08:00">2019-01-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-11 16:22:57" itemprop="dateModified" datetime="2019-01-11T16:22:57+08:00">2019-01-11</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/09/InnoDB关键特性/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/09/InnoDB关键特性/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="插入缓冲-Insert-Buffer-以及它解决的问题"><a href="#插入缓冲-Insert-Buffer-以及它解决的问题" class="headerlink" title="插入缓冲(Insert Buffer)以及它解决的问题"></a>插入缓冲(Insert Buffer)以及它解决的问题</h3><p> 插入缓冲这个名字可能会让人以为插入缓冲是缓冲池的一个组成部分，其实不然，插入缓冲和数据页一样，都是物理页的一个组成部分，插入缓冲为解决非聚集索引的写性能问题（插入或更新）而设计。对非聚集索引的插入或更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入；不在则先放入到一个Insert Buffer对象中，此时起到了欺骗的效果，看似数据库这个非聚集索引已经插入到了叶子节点，然而并非如此，只是存放在另一个位置。然后再以一定的频率以及情况进行Insert Buffer同辅助索引页子节点的merge操作，此时通常能将多个插入合并到一个操作中，这就大大提高了<strong>非聚集索引插入的性能</strong>。</p>
<p>Insert Buffer的使用要满足以下两个条件：</p>
<ul>
<li>索引是辅助索引</li>
<li>索引不是唯一的</li>
</ul>
<p>满足以上两个条件时使用Insert Buffer，提高插入操作的性能。不过有这样一种情况，即应用程序进行大量的插入操作，这些都涉及了不唯一的非聚集索引，即使用了Insert Buffer。若此时Mysql数据库发生了宕机，肯定有大量的Insert Buffer未合并到实际的非聚集索引中，此时要恢复可能会耗费很长的时间。</p>
<p>目前，Insert Buffer存在一个问题，即写密集的情况下，插入缓冲会占用过多缓冲池内存(innodb_buffer_pool)，默认最大可以占用1/2的缓冲池内存。修改IBUF_POOL_SIZE_PER_MAX_SIZE就可以对插入缓冲的大小进行控制，比如将IBUF_POOL_SIZE_PER_MAX_SIZE改为3，则最大只能使用1/3的缓冲池内存。</p>
<p>现在说说插入缓冲具体是什么，Insert Buffer的数据结构是一棵B+树，现在的MySQL版本中，全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer，而这棵B+树存放在共享表空间中，即ibdata1中。因此通过独立表空间ibd文件恢复表中数据时往往会导致CHECK TABLE失败。因为表辅助索引的数据还在Insert Buffer中，即共享表空间中，通过ibd文件恢复后，还需要进行REPAIR TABLE来重建表上的辅助索引。</p>
<h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>哈希(hash)是一种非常快的查询方法，一般情况下这种查找的时间复杂度为O(1)，一般需要一次查找即可定位数据，而B+树的查询次数，取决于B+树的高度，常需要3到4次的查询。</p>
<p>自适应哈希索引(adaptive hash index)，是InnoDB引擎的一个特殊功能，当InnoDB发现某些索引值使用十分频繁时，它会在内存中基于B-Tree索引上再创建一个哈希索引，这样可以让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。自适应哈希索引是一个完全自动的内部行为，用户无法控制或配置，但是有必要的话可以关闭该功能。</p>
<p>InnoDB存储引擎监控对一个表上各个索引页的查询，若是发现在索引页上建立哈希索引可以带来速度提升，则建立哈希索引，称为自适应哈希索引(AHI)。AHI由缓冲池的B+树页建立哈希索引，建立速度很快，不需要对整张表建立哈希索引。InnoDB存储引擎自动根据访问频率和模式来自动为某些热点页建立哈希索引。</p>
<p>AHI有一个要求，即对这个页的连续访问模式必须是一样的。比如对(a,b)这样的联合索引页，访问模式可以是以下情况：</p>
<ul>
<li><p>WHERE a=xxx</p>
</li>
<li><p>WHERE a=xxx AND b=xxx</p>
</li>
</ul>
<p>访问模式一样指查询条件一样，交替进行上述两种查询的话，则InnoDB存储引擎不会对该页构造AHI。启用AHI后，读取和写入速度可以提高2倍。辅助索引的连接操作性能可以提高5倍。AHI是一种非常好的优化模式，其设计思想为数据库自优化，无需DBA进行人为的调整。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> <span class="keyword">INNODB</span> <span class="keyword">STATUS</span></span><br></pre></td></tr></table></figure>
<p>通过此命令可以看到当前AHI的使用情况。</p>
<p>注意哈希索引只能用来搜索等值的查询，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> index_col=<span class="string">'XXX'</span></span><br></pre></td></tr></table></figure>
<p>对于其他查找类型比如范围查找，不能使用范围索引，因此SHOW ENGINE INNODB STATUS结果中出现了non-hash searches/s的情况。AHI由InnoDB引擎控制，用户只能通过SHOW ENGINE INNODB STATUS的结果以及参数innodb_adaptive_hash_index来考虑是否启用此特性，默认情况下AHI是开启的。</p>
<h3 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h3><p>Insert Buffer和AHI关注InnoDB性能上的提升，而doublewrite(两次写)带给InnoDB的是数据页的可靠性。发生数据库宕机时，InnoDB存储引擎可能正在写入某个页到表中，而这个页只写了一部分，比如说一个16kb的页，只写了前4kb，之后数据库就宕机了，这种情况叫做部分写失效(partial page write)。在InnoDB存储引擎中未使用doublewrite技术前，曾有因为部分写失效导致数据丢失的情况。</p>
<p>doublewrite分为两部分，一部分是内存中的doublewrite buffer，大小2M，另一部分是磁盘上共享表空间的连续128个页，大小也是2M。对缓冲池脏页进行刷新时，先用memcpy函数将脏页复制到内存的doublewrite buffer，然后由doublewrite buffer再分为两次，每次1MB顺序写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘。doublewrite页(共享表空间的页)是连续的，所以这是一个顺序的过程，并没有很大的开销。若操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，复制到表空间文件再应用重做日志。完成共享表空间相关的写入后，再将doublewrite buffer中的页写入各个表空间文件中，而此时的写入则是离散的，因为各个表空间可能在磁盘的不同位置。</p>
<p>如果操作系统在将页写入磁盘的过程中发生了崩溃，恢复过程中，InnoDB可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。</p>
<p>参数skip_innodb_doublewrite可以禁用doublewrite功能，可能导致前面提及的写失效问题，对于需要提供数据高可靠性的主服务器(master server)，任何时候都应该确保开启doublewrite功能。</p>
<p><img src="/2019/01/09/InnoDB关键特性/1.JPG" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">段铭</p>
              <p class="site-description motion-element" itemprop="description">编程随想</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">段铭</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  

  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  




  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
